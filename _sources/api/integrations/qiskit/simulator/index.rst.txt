:py:mod:`integrations.qiskit.simulator`
=======================================

.. py:module:: integrations.qiskit.simulator


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   simulator/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   integrations.qiskit.simulator.QiskitSimulator




.. py:class:: QiskitSimulator(device_name: str, noise_model: Optional[qiskit.providers.aer.noise.NoiseModel] = None, device_connectivity: Optional[orquestra.quantum.circuits.layouts.CircuitConnectivity] = None, basis_gates: Optional[List] = None, api_token: Optional[str] = None, optimization_level: int = 0, seed: Optional[int] = None, **kwargs)

   Bases: :py:obj:`orquestra.quantum.api.backend.QuantumSimulator`

   .. py:attribute:: supports_batching
      :annotation: = False

      

   .. py:attribute:: batch_size
      

      

   .. py:method:: get_device(noisy=False, **kwargs)

      Get the ibm device used for executing circuits

      :param noisy: a boolean indicating if the user wants to use noisy
                    simulations
      :type noisy: bool

      :returns: The ibm device that can use the ibm execute api


   .. py:method:: run_circuit_and_measure(circuit: orquestra.quantum.circuits.Circuit, n_samples: int) -> orquestra.quantum.measurements.Measurements

      Run a circuit and measure a certain number of bitstrings. Note: the
      number of bitstrings measured is derived from self.n_samples

      :param circuit: the circuit to prepare the state
      :param n_samples: The number of samples to collect.



