:orphan:

:py:mod:`orquestra.integrations.qiskit.runner._qiskit_runner`
=============================================================

.. py:module:: orquestra.integrations.qiskit.runner._qiskit_runner


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   orquestra.integrations.qiskit.runner._qiskit_runner.QiskitRunner



Functions
~~~~~~~~~

.. autoapisummary::

   orquestra.integrations.qiskit.runner._qiskit_runner.prepare_for_running_on_backend



Attributes
~~~~~~~~~~

.. autoapisummary::

   orquestra.integrations.qiskit.runner._qiskit_runner.AnyQiskitBackend


.. py:data:: AnyQiskitBackend
   

   

.. py:function:: prepare_for_running_on_backend(circuit: orquestra.quantum.circuits.Circuit) -> qiskit.QuantumCircuit


.. py:class:: QiskitRunner(qiskit_backend: AnyQiskitBackend, noise_model: Optional[qiskit_aer.noise.NoiseModel] = None, coupling_map: Optional[qiskit.transpiler.CouplingMap] = None, basis_gates: Optional[List[str]] = None, optimization_level: int = 0, seed: Optional[int] = None, execute_function=execute)

   Bases: :py:obj:`orquestra.quantum.api.BaseCircuitRunner`

   ABC for implementing simple circuit runners.

   To implement this ABC, override at least `_run_and_measure` method.
   In addition, if your runner supports more sophisticated way of
   running multiple circuits in a batch, you can override the
   `_run_batch_and_measure` method.

   .. note::

      For purpose of counting executed jobs and circuits, this ABC
      makes assumption that each call to _run_and_measure constitutes
      a single job. If this assumption is not valid, you should avoid
      inheriting this class and instead implement CircuitRunner protocol
      separately.


