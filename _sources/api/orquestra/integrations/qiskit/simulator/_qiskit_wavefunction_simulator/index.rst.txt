:orphan:

:py:mod:`orquestra.integrations.qiskit.simulator._qiskit_wavefunction_simulator`
================================================================================

.. py:module:: orquestra.integrations.qiskit.simulator._qiskit_wavefunction_simulator


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   orquestra.integrations.qiskit.simulator._qiskit_wavefunction_simulator.QiskitWavefunctionSimulator




.. py:class:: QiskitWavefunctionSimulator(qiskit_backend: orquestra.integrations.qiskit.runner._qiskit_runner.AnyQiskitBackend, noise_model: Optional[qiskit_aer.noise.NoiseModel] = None, device_connectivity: Optional[orquestra.quantum.circuits.layouts.CircuitConnectivity] = None, basis_gates: Optional[List[str]] = None, optimization_level: int = 0, seed: Optional[int] = None)

   Bases: :py:obj:`orquestra.quantum.api.wavefunction_simulator.BaseWavefunctionSimulator`

   ABC for implementing simple wavefunction simulators.

   This ABC is build around _get_wavefunction_from_native_circuit
   method. In general, most simulators wrap some third-party resource (
   a library, service, API etc.), which can only consume circuits comprising
   operations from a given set. Such operations are called "native" to
   the given simulator, whereas other operations are called "nonnative".

   The idea of simulating arbitrary circuit is thus as follows:
   - split circuit into alternating consecutive parts of only native and
     only "nonnative" operations.
   - start with some initial state
   - for each part:
     - if it is native, run it via third-party resource, save the new
       statevector
     - if it is nonnative, apply each operation in the sequence using
       operation.apply(previous_statevector). Save the new statevector.
     Last saved statevector is the wavefunction of the total circuit.

     For this to work, subclasses of this ABC should implement
     _get_wavefunction_from_the_native_circuit method.

     Note:
         Since this class inherits all the limitations of BaseCircuitRunner.
         The _run_and_measure function is implemented via sampling from the
         wavefunction. Care must be taken when using third-party service that
         implements more sophisticated/more performant sampling method not
         involving direct computation of the whole wavefunction. In such cases,
         using BaseWavefunctionSimulator ABC will likely result in huge
         performance hit.


