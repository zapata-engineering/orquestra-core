:py:mod:`orquestra.opt.cost_function_augmentations`
===================================================

.. py:module:: orquestra.opt.cost_function_augmentations

.. autoapi-nested-parse::

   Implementation of cost function augmentations.

   The "augmentation" is a function returning function. Augmentations can add side effects
   to the function invocation (like logging or recording history), or even modify the
   return value.

   Cost functions are augmented via `augment_cost_function`. Basic usage looks as follows

   .. code:: python

      augmented_func = augment_cost_function(func, [function_logger(level=level)])

   If the function to be augmented has gradient, separate augmentations can be applied
   to the function and the gradient, e.g.:

   .. code:: python

      augmented_func = augment_cost_function(
          func,
          cost_function_augmentations=[function_logger(level=logging.INFO)],
          gradient_augmentations=[function_logger(level=logging.DEBUG)]
      )


   In principle, any function mapping cost function to cost function can be used as
   augmentation. The common pattern however is an augmentation that triggers a side
   effect, possibly when some conditions are met, and otherwise leaves the augmented
   function unchanged. The `function_logger` augmentations is an example of such
   augmentation.

   There is a shortcut for implementing augmentations like function_logger. The required
   steps are:
   - Create class inheriting ConditionalSideEffect.
   - Implement _act method, that defines what the side effect is.
   - Create a thin wrapper function that constructs actual augmentation.
   Refer to `function_logger` below for an example of this process.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   orquestra.opt.cost_function_augmentations.ConditionalSideEffect
   orquestra.opt.cost_function_augmentations.FunctionLogger



Functions
~~~~~~~~~

.. autoapisummary::

   orquestra.opt.cost_function_augmentations.augment_cost_function
   orquestra.opt.cost_function_augmentations.function_logger



Attributes
~~~~~~~~~~

.. autoapisummary::

   orquestra.opt.cost_function_augmentations.FunctionAugmentation


.. py:data:: FunctionAugmentation
   

   

.. py:function:: augment_cost_function(cost_function: orquestra.opt.api.CostFunction, cost_function_augmentations: Optional[Iterable[FunctionAugmentation]] = None, gradient_augmentations: Optional[Iterable[FunctionAugmentation]] = None)

   Augment a function and its gradient.

   :param cost_function: a function to be augmented.
   :param cost_function_augmentations: augmentations to be applied to cost_function
                                       itself, in left-to-right order.
   :param gradient_augmentations: augmentations to be applied to a gradient. If the
                                  cost_function has no `gradient` attribute, this argument is ignored.

   :returns: A function with all application applied to it. The returned object
             has all attributes present in cost_function. The same is true about
             gradient. The exact behaviour of the returned object depends on the
             augmentations used, and the order in which they were applied.


.. py:class:: ConditionalSideEffect(function: Callable, predicate: orquestra.opt.api.SaveCondition = always)

   Bases: :py:obj:`abc.ABC`

   Base class for implementing augmentations that trigger some side effect.

   ConditionalSideEffect implementations don't modify the return value of
   the wrapped function, but trigger some additional action, possibly
   only when some conditions are met.

   :param function: a single argument function to be wrapped
   :param predicate: a function with signature (result, params, call_number) where
                     function(params) = result and call_number indicates how many times this
                     object has been called so far. The side effect is triggerred if and only
                     if predicate(result, params, call_number) is True. By default, side
                     effect is triggerred always.

   .. attribute:: function

      function passed to the initializer

   .. attribute:: predicate

      predicate passed to the initializer

   .. attribute:: call_number

      number indicating how many calls have been made to this
      function so far.

   .. rubric:: Notes

   Since no synchronization is implemented, ConditionalSideEffects are inherently
   unsuitable for multi-threaded use.

   Concrete subclasses of ConditionalSideEffect need to implement _act method.


.. py:class:: FunctionLogger(function: Callable, predicate: orquestra.opt.api.SaveCondition = always, logger=None, level=logging.INFO, message='Function called. Call number: %d, function value: %s')

   Bases: :py:obj:`ConditionalSideEffect`

   Side effect causing function call to be logged.

   :param function: function to be wrapped.
   :param predicate: boolean function defining when the logging should happen. See
                     ConditionalSideEffect for more detailed description.
   :param logger: logger to be used. If not provided, logger with __name__ name will
                  be used.
   :param level: log level to be used for logging messages. The default is INFO.
   :param message: %-style template string for message to be printed. Message will be
                   constructed by passing format arguments (call number, function value).


.. py:function:: function_logger(predicate: orquestra.opt.api.SaveCondition = always, logger=None, level=logging.INFO, message='Function called. Call number: %d, function value: %s')

   Cost function augmentation adding logging.

   For description of parameters see FunctionLogger class above.


