:py:mod:`orquestra.opt.problems`
================================

.. py:module:: orquestra.opt.problems


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   generators/index.rst
   graph/index.rst
   graph_partition/index.rst
   max_independent_set/index.rst
   maxcut/index.rst
   vertex_cover/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   orquestra.opt.problems.GraphPartitioning
   orquestra.opt.problems.MaxIndependentSet
   orquestra.opt.problems.MaxCut
   orquestra.opt.problems.VertexCover



Functions
~~~~~~~~~

.. autoapisummary::

   orquestra.opt.problems.solve_problem_by_exhaustive_search
   orquestra.opt.problems.get_random_ising_hamiltonian



.. py:function:: solve_problem_by_exhaustive_search(hamiltonian: orquestra.quantum.operators.PauliSum) -> Tuple[float, List[Tuple[int, Ellipsis]]]

   Solves any QAOA cost hamiltonian using exhaustive search.

   It searches for degeneracy and returns all the best solutions if more than one
   exists.

   :param hamiltonian: cost hamiltonian

   :returns: value of the best solution
             List[Tuple[int]]: list of solutions which correspond to the best value, each
                 solution is a tuple of ints.
   :rtype: float


.. py:function:: get_random_ising_hamiltonian(number_of_qubits: int, number_of_terms: int, max_number_of_qubits_per_term: int) -> orquestra.quantum.operators.PauliSum

   Generates a random Hamiltonian for a given number of qubits and terms with
   weights between -1 and 1.

   NOTE: Due to randomness, we cannot ensure that the returned hamiltonian has an
       operation on every qubit.

   :param number_of_qubits: The number of qubits in the Hamiltonian. Should be >= 2.
   :param max_number_qubits_per_term: The maximum number of qubits for each term in the
                                      hamiltonian. Should be <= number_of_qubits.


.. py:class:: GraphPartitioning

   Bases: :py:obj:`orquestra.opt.api.problem.Problem`

   Solves the graph partitioning problem for undirected, unweighted graph using
   an ising model formulation.

   The solution of a graph partitioning  problem is the set of nodes S that minimizes
   the weight of the edges between S and the rest of the graph. S must contain half
   the nodes in the graph.

   From "Ising formulations of many NP problems" by A. Lucas, page 6, eqs 7-9
   (https://arxiv.org/pdf/1302.5843.pdf).


.. py:class:: MaxIndependentSet

   Bases: :py:obj:`orquestra.opt.api.problem.Problem`

   Solves maximum independent set problem on an undirected graph using an
   ising model formulation.

   The solution to a maximum independent set is the largest set of nodes
   which do not share an edge.
   Based on "Efficient Combinatorial Optimization Using Quantum Annealing" p. 8
   (https://arxiv.org/pdf/1801.08653.pdf)
   and also mentioned briefly in
   "Ising formulations of many NP problems" by A. Lucas, page 11 section 4.2
   (https://arxiv.org/pdf/1302.5843.pdf).


.. py:class:: MaxCut

   Bases: :py:obj:`orquestra.opt.api.problem.Problem`

   Solves max cut problem on an undirected weighted graph using an ising model
   formulation.

   The solution of a maxcut problem is the set of nodes S that maximizes the
   wieght of the edges connecting the nodes in S to the rest of the graph.
   From "A Quantum Approximate Optimization Algorithm" by E. Farhi, eq. 12
   (https://arxiv.org/pdf/1411.4028.pdf)
   and
   "Performance of the Quantum Approximate Optimization Algorithm on the Maximum
   Cut Problem" eq. 1 (https://arxiv.org/pdf/1811.08419.pdf).


.. py:class:: VertexCover(A: int = 5, B: int = 1)

   Bases: :py:obj:`orquestra.opt.api.problem.Problem`

   Solves vertex cover problem on an undirected graph using an ising model
   formulation.

   The solution of a vertex cover problem is the minimal number of colored
   verticies such that all edges connect to a colored vertex.
   From "Ising formulations of many NP Problems" by A. Lucas, eq. 33 and 34
   (https://arxiv.org/pdf/1302.5843.pdf)
   and
   https://quantumcomputing.stackexchange.com/questions/16082/vertex-cover-mappings-from-qubo-to-ising-and-vice-versa
   for corrective translation shifts

   :param A: Cost of having an edge which is not connected to a colored vertex.
   :param Should be large:
   :type Should be large: _A = 5
   :param B: Cost of coloring a particular vertex.

   .. attribute:: _A

      See argument A above.

   .. attribute:: _B

      See argument B above.


