:py:mod:`orquestra.quantum.api.circuit_runner`
==============================================

.. py:module:: orquestra.quantum.api.circuit_runner

.. autoapi-nested-parse::

   Definition of CircuitRunner protocol and ABC for implementing it.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   orquestra.quantum.api.circuit_runner.CircuitRunner
   orquestra.quantum.api.circuit_runner.BaseCircuitRunner




.. py:class:: CircuitRunner

   Bases: :py:obj:`Protocol`

   Protocol for objects able to run circuits and collect measurements.

   This protocol is a pure interface and does not contain any default
   implementations. See BaseCircuitRunner ABC that can be extended to
   implement simple CircuitRunner.

   .. note:: This protocol was previously known as QuantumBackend.

   .. py:method:: run_and_measure(circuit: orquestra.quantum.circuits.Circuit, n_samples: int) -> orquestra.quantum.measurements.Measurements

      Run circuit given number of times and return obtained measurements.

      :param circuit: a circuit to be run.
      :param n_samples: minimum number of times the circuit should be run. This
                        is sometimes called "number of shots" in other SDKs.

      :returns: A Measurements object containing *at least* n_samples.

      :raises ValueError: if n_samples is not positive.

      .. note::

         For some runners, the returned number of measurements might be
         actually larger than n_samples. Runner - independent code should
         take it into account and not rely on the assumption
         len(measurement.bitstrings) == n_samples


   .. py:method:: run_batch_and_measure(circuits_batch: Sequence[orquestra.quantum.circuits.Circuit], n_samples: Union[int, Sequence[int]]) -> List[orquestra.quantum.measurements.Measurements]

      Run multiple circuits and return measurements for each circuit.

      Essentially, this method performs the same as `run_and_measure` for
      a single circuit. However, some runners may be able to submit multiple
      circuits at once (thus possibly reducing costs), or run multiple
      circuits in parallel (thus increasing performance). For this reasons,
      usage of run_batch_and_measure is always recommended over
      run_and_measure if one needs to run multiple circuits.

      :param circuits_batch: sequence of circuits to be run.
      :param n_samples: minimum number of times each circuit should be run. If
                        a single integer N is passed, each circuit will be run at least
                        N times. If a sequence of integers is passed, it must be of the
                        same length as circuits_batch and i-th number is treated as
                        minimum number of runs for i-th circuit.

      :returns: A list of measurements such that i-th object corresponds to i-th
                circuit.

      :raises ValueError:
      :raises - for integral n_samples if it is not positive:
      :raises - if any element of n_samples sequence is not positive, or n_samples: has length differing from circuits_batch.

      .. note::

         Similarly as with `run_and_measure` method, clients of circuit
         runners can only assume number of returned samples is greater
         or equal to the requested one. Furthermore, clients should not
         assume that each cicruict has been run the same number of times.


   .. py:method:: get_measurement_outcome_distribution(circuit: orquestra.quantum.circuits.Circuit, n_samples: Optional[int]) -> orquestra.quantum.distributions.MeasurementOutcomeDistribution

      Get a distribution of measurement outcomes from a given circuit.

      This is essentially the same as `run_and_measure`, except that
      a frequency of obtained outcomes is returned rather than a
      Measurements object.

      If `n_samples` is equal to None, supported samplers may returned
      exact distribution instead of an empirical one.


   .. py:method:: n_jobs_executed() -> int
      :property:

      Number of jobs executed by this runner.

      For circuit runners wrapping external resources or simulators,
      this number determines how many calls were made to the external
      library or API.


   .. py:method:: n_circuits_executed() -> int
      :property:

      Total number of circuits executed by this runner.

      .. note::

         This number is counted with repetitions. For instance, if the
         same circuit has to be run multiple times to obtain required number
         of samples.



.. py:class:: BaseCircuitRunner

   Bases: :py:obj:`abc.ABC`, :py:obj:`CircuitRunner`

   ABC for implementing simple circuit runners.

   To implement this ABC, override at least `_run_and_measure` method.
   In addition, if your runner supports more sophisticated way of
   running multiple circuits in a batch, you can override the
   `_run_batch_and_measure` method.

   .. note::

      For purpose of counting executed jobs and circuits, this ABC
      makes assumption that each call to _run_and_measure constitutes
      a single job. If this assumption is not valid, you should avoid
      inheriting this class and instead implement CircuitRunner protocol
      separately.

   .. py:method:: run_and_measure(circuit: orquestra.quantum.circuits.Circuit, n_samples: int) -> orquestra.quantum.measurements.Measurements

      Run circuit given number of times and return obtained measurements.

      See docstrings of CircuitRunner protocol for exact description of
      parameters.

      .. note::

         Subclasses of `BaseCircuitRunner` ABC should not override this method.
         Instead, implement `_run_and_measure`.


   .. py:method:: run_batch_and_measure(circuits_batch: Sequence[orquestra.quantum.circuits.Circuit], n_samples: Union[int, Sequence[int]]) -> List[orquestra.quantum.measurements.Measurements]

      Run multiple circuits and return measurements for each circuit.

      See docstrings of CircuitRunner protocol for exact description of
      parameters.

      .. note::

         Subclasses of `BaseCircuitRunner` ABC should not override this method.
         Instead, implement `_run_and_measure` method and, if you have a
         dedicated way of running circuits' batch, `_run_batch_and_measure`
         method.


   .. py:method:: n_jobs_executed() -> int
      :property:

      Number of executed jobs.


   .. py:method:: n_circuits_executed() -> int
      :property:

      Number of executed circuits.


   .. py:method:: get_measurement_outcome_distribution(circuit: orquestra.quantum.circuits.Circuit, n_samples: Optional[int]) -> orquestra.quantum.distributions.MeasurementOutcomeDistribution

      Get a distribution of measurement outcomes from a given circuit.

      :param circuit: circuit to be sampled
      :param n_samples: number of times `circuit` should be sampled

      :returns: An object representing empirical distribution of measured bitstrings

      :raises ValueError: if n_samples is None or n_samples is not positive.



