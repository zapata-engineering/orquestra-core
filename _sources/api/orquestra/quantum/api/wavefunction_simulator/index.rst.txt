:py:mod:`orquestra.quantum.api.wavefunction_simulator`
======================================================

.. py:module:: orquestra.quantum.api.wavefunction_simulator

.. autoapi-nested-parse::

   The WavefunctionSimulator protocol and ABC for implementing it.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   orquestra.quantum.api.wavefunction_simulator.WavefunctionSimulator
   orquestra.quantum.api.wavefunction_simulator.BaseWavefunctionSimulator




.. py:class:: WavefunctionSimulator

   Bases: :py:obj:`orquestra.quantum.api.circuit_runner.CircuitRunner`, :py:obj:`Protocol`

   The protocol for objects able to compute the wavefunction.

   .. py:method:: get_wavefunction(circuit: orquestra.quantum.circuits.Circuit, initial_state: Optional[orquestra.quantum.typing.StateVector] = None) -> orquestra.quantum.wavefunction.Wavefunction

      Get a wavefunction of a circuit starting from a given initial state.

      :param circuit: circuit whose wavefunction is to be computed.
      :param initial_state: state used as an input to the `circuit`. If not provided,
                            |0...0> will be used.

      :returns: Wavefunction comprising 2 ** n amplitudes, where n is number of qubits in
                `circuit`.


   .. py:method:: get_exact_expectation_values(circuit: orquestra.quantum.circuits.Circuit, operator: orquestra.quantum.operators.PauliRepresentation) -> float

      Get an exact expectation value of an operator.

      :param circuit: circuit constructing state for which expectation value
                      is to be computed.
      :param operator: operator of which expectation value should be computed.

      :returns: An expectation value as a single floating point number.



.. py:class:: BaseWavefunctionSimulator(*, seed: Optional[int] = None)

   Bases: :py:obj:`orquestra.quantum.api.circuit_runner.BaseCircuitRunner`, :py:obj:`WavefunctionSimulator`

   ABC for implementing simple wavefunction simulators.

   This ABC is build around _get_wavefunction_from_native_circuit
   method. In general, most simulators wrap some third-party resource (
   a library, service, API etc.), which can only consume circuits comprising
   operations from a given set. Such operations are called "native" to
   the given simulator, whereas other operations are called "nonnative".

   The idea of simulating arbitrary circuit is thus as follows:
   - split circuit into alternating consecutive parts of only native and
     only "nonnative" operations.
   - start with some initial state
   - for each part:
     - if it is native, run it via third-party resource, save the new
       statevector
     - if it is nonnative, apply each operation in the sequence using
       operation.apply(previous_statevector). Save the new statevector.
     Last saved statevector is the wavefunction of the total circuit.

     For this to work, subclasses of this ABC should implement
     _get_wavefunction_from_the_native_circuit method.

     Note:
         Since this class inherits all the limitations of BaseCircuitRunner.
         The _run_and_measure function is implemented via sampling from the
         wavefunction. Care must be taken when using third-party service that
         implements more sophisticated/more performant sampling method not
         involving direct computation of the whole wavefunction. In such cases,
         using BaseWavefunctionSimulator ABC will likely result in huge
         performance hit.

   .. py:method:: run_and_measure(circuit: orquestra.quantum.circuits.Circuit, n_samples: int) -> orquestra.quantum.measurements.Measurements

      Run circuit given number of times and return obtained measurements.

      See docstrings of CircuitRunner protocol for exact description of
      parameters.

      .. note::

         For BaseWavefunctionSimulator, running a circuit comprising computing
         its wavefunction and then sampling from the probability distribution
         that it defines.


   .. py:method:: get_wavefunction(circuit: orquestra.quantum.circuits.Circuit, initial_state: Optional[orquestra.quantum.typing.StateVector] = None) -> orquestra.quantum.wavefunction.Wavefunction

      Get a wavefunction of a circuit starting from a given initial state.

      See docstrings of WavefunctionSimulator protocol for exact description of
      parameters.


   .. py:method:: get_exact_expectation_values(circuit: orquestra.quantum.circuits.Circuit, operator: orquestra.quantum.operators.PauliRepresentation) -> float

      Get an exact expectation value of an operator.

      See docstrings of WavefunctionSimulator protocol for exact description of
      parameters.


   .. py:method:: is_natively_supported(operation: orquestra.quantum.circuits.Operation) -> bool

      Determine if given operation is natively supported by this simulator.

      By default, operation is natively supported iff it is a GateOperation.
      However, this doesn't have to be true for every simulator.
      If the set of natively supported operations is different for
      some simulator, this method should be changed accordingly.

      :param operation: operation to be checked.

      :returns: True if `operation` is natively supported and False otherwise.


   .. py:method:: get_measurement_outcome_distribution(circuit: orquestra.quantum.circuits.Circuit, n_samples: Optional[int] = None) -> orquestra.quantum.distributions.MeasurementOutcomeDistribution

      Get a distribution of measurement outcomes from a given circuit.

      :param circuit: circuit to be sampled
      :param n_samples: number of times `circuit` should be sampled or None, if
      :param exact computation should be performed.:

      :returns: An object representing empirical (for integral n_samples) or theoretical
                (n_samples is None) distribution of measured bitstrings



