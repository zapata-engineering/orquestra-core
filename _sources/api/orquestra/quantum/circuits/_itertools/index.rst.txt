:orphan:

:py:mod:`orquestra.quantum.circuits._itertools`
===============================================

.. py:module:: orquestra.quantum.circuits._itertools


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   orquestra.quantum.circuits._itertools.split_into_batches
   orquestra.quantum.circuits._itertools.expand_sample_sizes
   orquestra.quantum.circuits._itertools.combine_measurement_counts



Attributes
~~~~~~~~~~

.. autoapisummary::

   orquestra.quantum.circuits._itertools.T


.. py:data:: T
   

   

.. py:function:: split_into_batches(circuits: Sequence[T], n_samples_per_circuit: Sequence[int], max_batch_size: int) -> Iterable[Tuple[Sequence[T], int]]

   Split sequence of circuits and corresponding sample sizes into batches.

   The circuits are split into batches of length `max_batch_size`, except
   possibly the last batch that can be smaller. The number of samples
   for each batch is a maximum number of samples requested for the circuits
   in the chunk. To illustrate, consider the following input:

   - circuits=[c1, c2, c3, c4, c5]
   - n_samples_per_circuit=[n1, n2, n3, n4, n5]
   - max_batch_size=2

   Then the returned iterable contains the following tuples:

   ((c1, c2), max([n1, n2]))
   ((c3, c4), max([n3, n4]))
   ((c5,), n5)

   :param circuits: a sequence of circuits to be batched. Please note that
                    the exact type of the circuits does not matter, and hence
                    this function works for native Orquestra circuits as well as
                    circuits from other libraries/SDKs.
   :param n_samples_per_circuit: a sequence of numbers of length equal to
                                 len(circuits), s.t. n_samples_per_circuit[i] is number of
                                 samples requested for circuits[i].
   :param max_batch_size: maximum allowable size of batch. Typically it comes
                          from specific runner's restrictions.

   :returns: An iterable yielding tuples of the forms (circuits_chunk, n_samples)
             satisfying the following constraints:

             - len(circuits_chunk) <= max_batch_size
             - n_samples is large enough to accommodate sample sizes requested
               for each circuit in circuits_chunk

   :raises ValueError: if input sequences are not of equal length, or if
       max_batch_size is not positive.


.. py:function:: expand_sample_sizes(circuits: Sequence[T], n_samples_per_circuit: Sequence[int], max_sample_size: int) -> Tuple[Sequence[T], Sequence[int], Sequence[int]]

   Expand sample sizes for each circuit to fit maximum sample size.

   :param circuits: list of circuits to be expanded
   :param n_samples_per_circuit: list of sample sizes corresponding to each
                                 circuit
   :param max_sample_size: maximum allowable sample size

   :returns:

             - new_circuits: sequence of circuits containing all of the original, possibly
               duplicated, circuits
             - new_n_samples: list of integers of the same length as new_circuits,
               s.t. sum of all sample sizes corresponding to given circuit (counting
               duplicates) is equal to the original sample size
             - multiplicities: sequence of the same length as original sequence of
               circuits holding information on how many times given circuit has
               been duplicated in `new_circuits`
   :rtype: Tuple of three sequences (new_circuits, new_sample_sizes, multiplicities)


.. py:function:: combine_measurement_counts(all_measurements: Sequence[Dict[str, int]], multiplicities: Sequence[int]) -> Sequence[Dict[str, int]]

   Combine (aggregate) measurements of the same circuits run several times.

   Suppose multiplicities is a list [1, 2 ,3]. Then, the all_measurements should
   be a sequence of 1+2+3=6 elements m0,m1,m2,m3,m4,m5, and the results will
   contain three dictionaries M0, M1, M2 s.t.

   - M0 contains counts from m0 only
   - M1 comprises combined counts from m1 and m2
   - M2 comprises combined counts from m3, m4 and m5

   :param all_measurements: sequence of measurements containing measurements
                            gathered from some, possibly duplicated, circuits. The Measurement
                            objects corresponding to the same circuit should be placed next to
                            each other. Should have the same length as sum(multiplicities).
   :param multiplicities: sequence of positive integers marking groups of
                          consecutive measurements corresponding to the same circuit. For
                          instance, multiplicities [1, 2, 3] mean that first group of
                          measurements comprises 1 Measurement, second group comprises 2
                          consecutive Measurements, third group contains 3 consecutive
                          Measurements and so on.

   :returns: Sequence of combined measurements of length equal len(multiplicities)

   :raises ValueError: if len(all_measurements != sum(multiplicities)


