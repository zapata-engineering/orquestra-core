:py:mod:`orquestra.vqa.cost_function`
=====================================

.. py:module:: orquestra.vqa.cost_function


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   cost_function/index.rst
   qcbm_cost_function/index.rst


Package Contents
----------------


Functions
~~~~~~~~~

.. autoapisummary::

   orquestra.vqa.cost_function.add_normal_noise
   orquestra.vqa.cost_function.create_cost_function
   orquestra.vqa.cost_function.dynamic_circuit_estimation_tasks_factory
   orquestra.vqa.cost_function.expectation_value_estimation_tasks_factory
   orquestra.vqa.cost_function.fix_parameters
   orquestra.vqa.cost_function.substitution_based_estimation_tasks_factory
   orquestra.vqa.cost_function.sum_expectation_values
   orquestra.vqa.cost_function.create_QCBM_cost_function



.. py:function:: add_normal_noise(parameter_precision, parameter_precision_seed) -> orquestra.opt.api.cost_function.ParameterPreprocessor

   Preprocessor adding noise to the parameters.

   The added noise is iid normal with mean=0.0 and stdev=`parameter_precision`.

   :param parameter_precision: stddev of the noise distribution
   :param parameter_precision_seed: seed for random number generator. The generator
                                    is seeded during preprocessor creation (not during each preprocessor call).

   :returns: preprocessor


.. py:function:: create_cost_function(runner: orquestra.quantum.api.circuit_runner.CircuitRunner, estimation_tasks_factory: orquestra.quantum.api.estimation.EstimationTasksFactory, estimation_method: orquestra.quantum.api.estimation.EstimateExpectationValues = _by_averaging, parameter_preprocessors: Optional[Iterable[orquestra.opt.api.cost_function.ParameterPreprocessor]] = None, gradient_function: GradientFactory = finite_differences_gradient) -> orquestra.opt.api.cost_function.CostFunction

   This function can be used to generate callable cost functions for parametric
   circuits. This function is the main entry to use other functions in this module.

   :param runner: quantum runner used for evaluation.
   :param estimation_tasks_factory: function that produces estimation tasks from
                                    parameters. See example use case below for clarification.
   :param estimation_method: the estimator used to compute expectation value of target
                             operator.
   :param parameter_preprocessors: a list of callable functions that are applied to
                                   parameters prior to estimation task evaluation. These functions have to
                                   adhere to the ParameterPreprocessor protocol.
   :param gradient_function: a function which returns a function used to compute the
                             gradient of the cost function (see
                             orquestra.opt.gradients.finite_differences_gradient for reference)

   :returns: A callable CostFunction object.

   Example use case:
       target_operator = ...
       ansatz = ...

       estimation_factory = substitution_based_estimation_tasks_factory(
           target_operator, ansatz
       )
       noise_preprocessor = add_normal_noise(1e-5, seed=1234)

       cost_function = create_cost_function(
           runner,
           estimation_factory,
           parameter_preprocessors=[noise_preprocessor]
       )

       optimizer = ...
       initial_params = ...

       opt_results = optimizer.minimize(cost_function, initial_params)



.. py:function:: dynamic_circuit_estimation_tasks_factory(target_operator: orquestra.quantum.operators.PauliRepresentation, ansatz: orquestra.vqa.api.ansatz.Ansatz, estimation_preprocessors: Optional[List[orquestra.quantum.api.estimation.EstimationPreprocessor]] = None) -> orquestra.quantum.api.estimation.EstimationTasksFactory

   Creates a EstimationTasksFactory object that can be used to create
   estimation tasks dynamically with parameters provided on the fly. These
   tasks will evaluate the parametric circuit of an ansatz, without using
   a symbol-parameter map. Wow, a factory for factories!

   To be used with `create_cost_function`. See `create_cost_function` docstring
   for an example use case.

   :param target_operator: operator to be evaluated
   :param ansatz: ansatz used to evaluate cost function
   :param estimation_preprocessors: A list of callable functions used to create the
                                    estimation tasks. Each function must adhere to the EstimationPreprocessor
                                    protocol.

   :returns: An EstimationTasksFactory object.


.. py:function:: expectation_value_estimation_tasks_factory(target_operator: orquestra.quantum.operators.PauliRepresentation, parametrized_circuit: orquestra.quantum.circuits.Circuit, estimation_preprocessors: Optional[List[orquestra.quantum.api.estimation.EstimationPreprocessor]] = None, symbols_sort_key: SymbolsSortKey = str) -> orquestra.quantum.api.estimation.EstimationTasksFactory

   Creates a EstimationTasksFactory object that can be used to create
   estimation tasks that returns the estimated expectation value of the input
   target operator with respect to the state prepared by the parameterized
   quantum circuit when evaluated to the input parameters.

   To be used with `create_cost_function` to create ground state cost functions.
   See `create_cost_function` docstring for an example use case.

   :param target_operator: operator to be evaluated
   :param parametrized_circuit: parameterized circuit to prepare quantum states
   :param estimation_preprocessors: A list of callable functions used to create the
                                    estimation tasks. Each function must adhere to the EstimationPreprocessor
                                    protocol.
   :param symbols_sort_key: key defining ordering on parametrized_circuits free symbols.
                            If s1,...,sN are all free symbols in parametrized_circuit, and cost function
                            is called with `parameters` then the following binding occurs:
                            parameters[i] -> sorted([s1,...,sN], key=symbols_sort_key)[i]

   :returns: An EstimationTasksFactory object.


.. py:function:: fix_parameters(fixed_parameters: numpy.ndarray) -> orquestra.opt.api.cost_function.ParameterPreprocessor

   Preprocessor appending fixed parameters.

   :param fixed_parameters: parameters to be appended to the ones being preprocessed.

   :returns: preprocessor


.. py:function:: substitution_based_estimation_tasks_factory(target_operator: orquestra.quantum.operators.PauliRepresentation, ansatz: orquestra.vqa.api.ansatz.Ansatz, estimation_preprocessors: Optional[List[orquestra.quantum.api.estimation.EstimationPreprocessor]] = None) -> orquestra.quantum.api.estimation.EstimationTasksFactory

   Creates a EstimationTasksFactory object that can be used to create
   estimation tasks dynamically with parameters provided on the fly. These
   tasks will evaluate the parametric circuit of an ansatz, using a symbol-
   parameter map. Wow, a factory for factories! This is so meta.

   To be used with `create_cost_function`. See `create_cost_function` docstring
   for an example use case.

   :param target_operator: operator to be evaluated
   :param ansatz: ansatz used to evaluate cost function
   :param estimation_preprocessors: A list of callable functions used to create the
                                    estimation tasks. Each function must adhere to the EstimationPreprocessor
                                    protocol.

   :returns: An EstimationTasksFactory object.


.. py:function:: sum_expectation_values(expectation_values: orquestra.quantum.measurements.ExpectationValues) -> orquestra.quantum.utils.ValueEstimate

   Compute the sum of expectation values.

   If correlations are available, the precision of the sum is computed as

   \epsilon = \sqrt{\sum_k \sigma^2_k}

   where the sum runs over frames and \sigma^2_k is the estimated variance of
   the estimated contribution of frame k to the total. This is calculated as

   \sigma^2_k = \sum_{i,j} Cov(o_{k,i}, o_{k, j})

   where Cov(o_{k,i}, o_{k, j}) is the estimated covariance in the estimated
   expectation values of operators i and j of frame k.

   :param expectation_values: The expectation values to sum.

   :returns:

             The value of the sum, including a precision if the expectation values
                 included covariances.


.. py:function:: create_QCBM_cost_function(ansatz: orquestra.vqa.api.ansatz.Ansatz, runner: orquestra.quantum.api.CircuitRunner, n_samples: int, distance_measure: DistanceMeasure, distance_measure_parameters: dict, target_distribution: orquestra.quantum.distributions.MeasurementOutcomeDistribution, gradient_function: GradientFactory = finite_differences_gradient) -> orquestra.opt.api.cost_function.CostFunction

   Cost function used for evaluating QCBM.
   :param ansatz: the ansatz used to construct the variational circuits
   :param runner: runner used for QCBM evaluation
   :param distance_measure: function used to calculate the distance measure
   :param distance_measure_parameters: dictionary containing the relevant parameters
                                       for the chosen distance measure
   :param target_distribution: bistring distribution which QCBM aims to learn
   :param gradient_function: a function which returns a function used to compute
                             the gradient of the cost function
                             (see orquestra.opt.gradients.finite_differences_gradient for reference)

   :returns: Callable CostFunction object that evaluates the parametrized circuit produced
             by the ansatz with the given parameters and returns the distance between
             the produced bitstring distribution and the target distribution


