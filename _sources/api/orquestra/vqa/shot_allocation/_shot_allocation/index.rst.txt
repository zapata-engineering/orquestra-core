:orphan:

:py:mod:`orquestra.vqa.shot_allocation._shot_allocation`
========================================================

.. py:module:: orquestra.vqa.shot_allocation._shot_allocation


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   orquestra.vqa.shot_allocation._shot_allocation.allocate_shots_uniformly
   orquestra.vqa.shot_allocation._shot_allocation.allocate_shots_proportionally
   orquestra.vqa.shot_allocation._shot_allocation.estimate_nmeas_for_frames



.. py:function:: allocate_shots_uniformly(estimation_tasks: List[orquestra.quantum.api.estimation.EstimationTask], number_of_shots: int) -> List[orquestra.quantum.api.estimation.EstimationTask]

   Allocates the same number of shots to each task.

   :param number_of_shots: number of shots to be assigned to each EstimationTask


.. py:function:: allocate_shots_proportionally(estimation_tasks: List[orquestra.quantum.api.estimation.EstimationTask], total_n_shots: int, prior_expectation_values: Optional[orquestra.quantum.measurements.ExpectationValues] = None) -> List[orquestra.quantum.api.estimation.EstimationTask]

   Allocates specified number of shots proportionally to the variance associated
   with each operator in a list of estimation tasks. For more details please refer to
   the documentation of `orquestra.vqa.shot_allocation._shot_allocation`.

   :param total_n_shots: total number of shots to be allocated
   :param prior_expectation_values: object containing the expectation
                                    values of all operators in frame_operators


.. py:function:: estimate_nmeas_for_frames(frame_operators: List[orquestra.quantum.operators.PauliRepresentation], expecval: Optional[orquestra.quantum.measurements.ExpectationValues] = None) -> Tuple[float, int, numpy.ndarray]

   Calculates the number of measurements required for computing
   the expectation value of a qubit hamiltonian, where co-measurable terms
   are grouped in a single pauli operator, and different groups are different
   members of the list.

   We are assuming the exact expectation values are provided
   (i.e. infinite number of measurements or simulations without noise)
   :math:`M ~ (sum_{i} prec(H_i)) ** 2.0 / (epsilon ** 2.0)`
   where :math:`prec(H_i)` is the precision (square root of the variance)
   for each group of co-measurable terms H_{i}. It is computed as
   :math:`prec(H_{i}) = sum{ab} |h_{a}^{i}||h_{b}^{i}| cov(O_{a}^{i}, O_{b}^{i})`
   where :math:`h_{a}^{i}` is the coefficient of the a-th operator, :math:`O_{a}^{i}`,
   in the i-th group. Covariances are assumed to be zero for a != b:
   :math:`cov(O_{a}^{i},O_{b}^{i})=<O_{a}^{i}O_{b}^{i}>-<O_{a}^{i}><O_{b}^{i}>=0`

   :param frame_operators: A list of pauli operators, where
                           each element in the list is a group of co-measurable terms.
   :param expecval: An ExpectationValues object containing
                    the expectation values of all operators in frame_operators. If absent,
                    variances are assumed to be maximal (i.e. equal to the square of the
                    term's coefficient). Note that the term coefficients should be
                    included in the expectation values, e.g. the expectation value of
                    2*Z0 should be between -2 and 2.
                    NOTE: YOU HAVE TO MAKE SURE THAT THE ORDER OF EXPECTATION VALUES MATCHES
                    THE ORDER OF THE TERMS IN THE *GROUPED* TARGET QUBIT OPERATOR, OTHERWISE
                    THIS FUNCTION WILL NOT RETURN THE CORRECT RESULT.

   :returns: number of measurements for epsilon = 1.0
             nterms (int): number of groups in frame_operators
             frame_meas (np.array): Number of optimal measurements per group
   :rtype: K2 (float)


