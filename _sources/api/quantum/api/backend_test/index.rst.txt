:py:mod:`quantum.api.backend_test`
==================================

.. py:module:: quantum.api.backend_test

.. autoapi-nested-parse::

   Test case prototypes that can be used in other projects.

   Note that this file won't be executed on its own by pytest.
   You need to define your own test cases that inherit from the ones defined here.

   Note regarding testing specific gates.

   To test that a gate is properly implemented, we can ask for its matrix representation
   and check that each entry is correct. In some quantum simulator packages,
   returning this matrix representation is either not possible or difficult to implement.
   In such cases, we can check that the gate implementation is correct by ensuring that
   the gate transforms input states to output states as expected. If the simulator has
   the capability to provide the wavefunction as an output, then we can check that
   the entries of the transformed wavefunction are correct. If the simulator does not
   have the capability of providing the wavefunction as an output, but only gives
   bitstring samples from the wavefunction, then we can check that the bitstring statistics
   are as expected after taking sufficiently many samples. In both of these cases where
   we cannot directly check the matrix corresponding to the gate, we must check the action
   of the gate on multiple inputs (and outputs in the sampling case). We can picture
   this process as a kind of "quantum process tomography" for gate unit testing.
   Mathematically, correctness is ensured if the span of the input and outputs spans the
   full vector space.  Checking a tomographically complete set of input and outputs could
   be time consuming, especially in the case of sampling. Furthermore, we expect that the
   bugs that will occur will lead to an effect on many inputs (rather than, say, a single
   input-output pair).  Therefore, we are taking here a slightly lazy, but efficient
   approach to testing these gates by testing how they transform a tomographically
   incomplete set of input and outputs.

   Gates tests use `backend_for_gates_test` instead of `backend` as an input parameter
   because:
   a) it has high chance of failing for noisy backends
   b) having execution time in mind it's a good idea to use lower number of samples.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   quantum.api.backend_test.QuantumBackendTests
   quantum.api.backend_test.QuantumBackendGatesTests
   quantum.api.backend_test.QuantumSimulatorTests
   quantum.api.backend_test.QuantumSimulatorGatesTest



Functions
~~~~~~~~~

.. autoapisummary::

   quantum.api.backend_test.skip_tests_for_excluded_gates



.. py:function:: skip_tests_for_excluded_gates(func)


.. py:class:: QuantumBackendTests

   .. py:method:: test_run_circuit_and_measure_correct_indexing(backend)


   .. py:method:: test_run_circuit_and_measure_fails_for_invalid_n_samples(backend, n_samples)


   .. py:method:: test_run_circuit_and_measure_correct_num_measurements_attribute(backend, n_samples)


   .. py:method:: test_if_all_measurements_have_the_same_number_of_bits(backend)


   .. py:method:: test_run_circuitset_and_measure(backend)


   .. py:method:: test_run_circuitset_and_measure_n_samples(backend)



.. py:class:: QuantumBackendGatesTests

   .. py:attribute:: exp_val_spread
      :annotation: = 1

      

   .. py:attribute:: gates_to_exclude
      :annotation: :List[str] = []

      

   .. py:method:: test_one_qubit_non_parametric_gates_using_expectation_values(backend_for_gates_test, initial_gate, tested_gate, target_values)


   .. py:method:: test_one_qubit_parametric_gates_using_expectation_values(backend_for_gates_test, initial_gate, tested_gate, params, target_values)


   .. py:method:: test_two_qubit_non_parametric_gates_using_expectation_values(backend_for_gates_test, initial_gates, tested_gate, operators, target_values)


   .. py:method:: test_two_qubit_parametric_gates_using_expectation_values(backend_for_gates_test, initial_gates, tested_gate, params, operators, target_values)



.. py:class:: QuantumSimulatorTests

   Bases: :py:obj:`QuantumBackendTests`

   .. py:attribute:: atol_wavefunction
      :annotation: = 1e-15

      

   .. py:attribute:: atol_wavefunction_element
      :annotation: = 1e-07

      

   .. py:attribute:: atol_distribution
      :annotation: = 1e-07

      

   .. py:method:: test_get_wavefunction(wf_simulator)


   .. py:method:: test_get_measurement_outcome_distribution_wf_simulators(wf_simulator)


   .. py:method:: test_get_exact_expectation_values(wf_simulator)


   .. py:method:: test_get_wavefunction_uses_provided_initial_state(wf_simulator)



.. py:class:: QuantumSimulatorGatesTest

   .. py:attribute:: atol_wavefunction
      :annotation: = 1e-15

      

   .. py:attribute:: gates_to_exclude
      :annotation: :List[str] = []

      

   .. py:method:: test_one_qubit_non_parametric_gates_using_amplitudes(wf_simulator, initial_gate, tested_gate, target_amplitudes)


   .. py:method:: test_one_qubit_parametric_gates_using_amplitudes(wf_simulator, initial_gate, tested_gate, params, target_amplitudes)


   .. py:method:: test_two_qubit_non_parametric_gates_using_amplitudes(wf_simulator, initial_gates, tested_gate, target_amplitudes)


   .. py:method:: test_two_qubit_parametric_gates_using_amplitudes(wf_simulator, initial_gates, tested_gate, params, target_amplitudes)



