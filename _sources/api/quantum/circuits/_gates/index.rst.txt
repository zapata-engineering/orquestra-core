:orphan:

:py:mod:`quantum.circuits._gates`
=================================

.. py:module:: quantum.circuits._gates

.. autoapi-nested-parse::

   Data structures for orquestra gates.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   quantum.circuits._gates.Gate
   quantum.circuits._gates.GateOperation
   quantum.circuits._gates.MatrixFactoryGate
   quantum.circuits._gates.ControlledGate
   quantum.circuits._gates.Dagger
   quantum.circuits._gates.Exponential
   quantum.circuits._gates.Power
   quantum.circuits._gates.CustomGateMatrixFactory
   quantum.circuits._gates.CustomGateDefinition



Functions
~~~~~~~~~

.. autoapisummary::

   quantum.circuits._gates.gate_is_parametric



Attributes
~~~~~~~~~~

.. autoapisummary::

   quantum.circuits._gates.CONTROLLED_GATE_NAME
   quantum.circuits._gates.DAGGER_GATE_NAME
   quantum.circuits._gates.EXPONENTIAL_GATE_NAME
   quantum.circuits._gates.POWER_GATE_SYMBOL


.. py:class:: Gate

   Bases: :py:obj:`Protocol`

   Interface of a quantum gate representable by a matrix, translatable to other
   frameworks and backends.

   See `orquestra.quantum.circuits` for a list of built-in gates and usage guide.

   .. py:method:: name() -> str
      :property:

      Globally unique name of the gate.

      Name is used in textual representation and dispatching in conversion between
      frameworks. Defining different gates with the same name as built-in ones
      is discouraged.


   .. py:method:: params() -> Tuple[quantum.circuits._operations.Parameter, Ellipsis]
      :property:

      Value of parameters bound to this gate.

      Length of `params` should be equal to number of parameters in gate initializer.
      In particular, nonparametric gates should always return ().

      Examples:
      - an `H` gate has no params
      - a `RX(np.pi)` gate has a single param with value of `np.pi`
      - a `RX(sympy.Symbol("theta"))` gate has a single symbolic param `theta`
      - a `RX(sympy.sympify("theta * alpha"))` gate has a single symbolic expression
          param `theta*alpha`

      We need it for translations to other frameworks and for serialization.


   .. py:method:: free_symbols() -> Iterable[sympy.Symbol]
      :property:

      Unbound symbols in the gate matrix.

      Examples:
      - an `H` gate has no free symbols
      - a `RX(np.pi)` gate has no free symbols
      - a `RX(sympy.Symbol("theta"))` gate has a single free symbol `theta`
      - a `RX(sympy.sympify("theta * alpha"))` gate has two free symbols, `alpha` and
          `theta`
      - a `RX(sympy.sympify("theta * alpha")).bind({sympy.Symbol("theta"): 0.42})`
          gate has one free symbol, `alpha`


   .. py:method:: num_qubits() -> int
      :property:

      Number of qubits this gate acts on.
      We need it because matrix is computed lazily, and we don't want to create matrix
      just to know the number of qubits.


   .. py:method:: matrix() -> sympy.Matrix
      :property:

      Unitary matrix describing gate's action on state vector.

      We need it to be able to implement .propagate() on the operation class.


   .. py:method:: controlled(num_control_qubits: int) -> Gate
      :abstractmethod:


   .. py:method:: dagger() -> Gate
      :property:


   .. py:method:: power(exponent: float) -> Gate
      :abstractmethod:

      Gate representing the underlying matrix raised to the power
      of the given exponent.


   .. py:method:: exp() -> Gate
      :property:

      Gate representing the exponential of the given gate.


   .. py:method:: bind(symbols_map: Dict[sympy.Symbol, quantum.circuits._operations.Parameter]) -> Gate
      :abstractmethod:


   .. py:method:: replace_params(new_params: Tuple[quantum.circuits._operations.Parameter, Ellipsis]) -> Gate
      :abstractmethod:



.. py:function:: gate_is_parametric(gate_ref, gate_params)


.. py:class:: GateOperation

   Represents applying a `Gate` to 1 or more qubits in a circuit.

   .. py:attribute:: gate
      :annotation: :Gate

      

   .. py:attribute:: qubit_indices
      :annotation: :Tuple[int, Ellipsis]

      

   .. py:method:: params() -> Tuple[quantum.circuits._operations.Parameter, Ellipsis]
      :property:


   .. py:method:: bind(symbols_map: Dict[sympy.Symbol, quantum.circuits._operations.Parameter]) -> GateOperation


   .. py:method:: replace_params(new_params: Tuple[quantum.circuits._operations.Parameter, Ellipsis]) -> GateOperation


   .. py:method:: lifted_matrix(num_qubits)


   .. py:method:: apply(amplitude_vector: orquestra.quantum.typing.ParameterizedVector) -> orquestra.quantum.typing.ParameterizedVector


   .. py:method:: free_symbols() -> Iterable[sympy.Symbol]
      :property:



.. py:class:: MatrixFactoryGate

   Data structure for a `Gate` with deferred matrix construction.

   Most built-in gates are instances of this class.
   See `orquestra.quantum.circuits` for built-in gates and usage guide.

   This class requires the gate definition to be present during deserialization, so
   it's not easily applicable for gates defined in Orquestra steps. If you want to
   define a new gate, check out `CustomGateDefinition` first.

   Keeping a `matrix_factory` instead of a plain gate matrix allows us to defer matrix
   construction to _after_ parameter binding. This saves unnecessary work in scenarios
   where we construct a quantum circuit and immediately bind parameter values. When
   done multiple times, e.g. for every gate in each optimization step, this can lead
   to major performance issues.

   :param name: Name of this gate. Implementers of new gates should make sure that the
                names are unique.
   :param matrix_factory: a callable mapping arbitrary number of parameters into gate
                          matrix. Implementers of new gates should make sure the returned matrices are
                          square and of dimension being 2 ** `num_qubits`.
   :param params: gate parameters - either concrete values or opaque symbols.
                  Will be passed to `matrix_factory` when `matrix` property is requested.
   :param num_qubits: number of qubits this gate acts on.

   .. py:attribute:: name
      :annotation: :str

      

   .. py:attribute:: matrix_factory
      :annotation: :Callable[Ellipsis, sympy.Matrix]

      

   .. py:attribute:: params
      :annotation: :Tuple[quantum.circuits._operations.Parameter, Ellipsis]

      

   .. py:attribute:: num_qubits
      :annotation: :int

      

   .. py:attribute:: is_hermitian
      :annotation: :bool = False

      

   .. py:method:: matrix() -> sympy.Matrix
      :property:

      Unitary matrix defining action of this gate.

      This is a computed property using `self.matrix_factory` called with parameters
          bound to this gate.


   .. py:method:: bind(symbols_map) -> MatrixFactoryGate


   .. py:method:: replace_params(new_params: Tuple[quantum.circuits._operations.Parameter, Ellipsis]) -> MatrixFactoryGate


   .. py:method:: controlled(num_controlled_qubits: int) -> Gate


   .. py:method:: dagger() -> Union[MatrixFactoryGate, Gate]
      :property:


   .. py:method:: exp() -> Gate
      :property:


   .. py:method:: power(exponent: float) -> Gate


   .. py:method:: free_symbols() -> Iterable[sympy.Symbol]
      :property:

      Unbound symbols in the gate matrix. See Gate.free_symbols for details.



.. py:data:: CONTROLLED_GATE_NAME
   :annotation: = Control

   

.. py:class:: ControlledGate

   Bases: :py:obj:`Gate`

   Interface of a quantum gate representable by a matrix, translatable to other
   frameworks and backends.

   See `orquestra.quantum.circuits` for a list of built-in gates and usage guide.

   .. py:attribute:: wrapped_gate
      :annotation: :Gate

      

   .. py:attribute:: num_control_qubits
      :annotation: :int

      

   .. py:method:: name()
      :property:

      Globally unique name of the gate.

      Name is used in textual representation and dispatching in conversion between
      frameworks. Defining different gates with the same name as built-in ones
      is discouraged.


   .. py:method:: num_qubits()
      :property:

      Number of qubits this gate acts on.
      We need it because matrix is computed lazily, and we don't want to create matrix
      just to know the number of qubits.


   .. py:method:: matrix()
      :property:

      Unitary matrix describing gate's action on state vector.

      We need it to be able to implement .propagate() on the operation class.


   .. py:method:: params()
      :property:

      Value of parameters bound to this gate.

      Length of `params` should be equal to number of parameters in gate initializer.
      In particular, nonparametric gates should always return ().

      Examples:
      - an `H` gate has no params
      - a `RX(np.pi)` gate has a single param with value of `np.pi`
      - a `RX(sympy.Symbol("theta"))` gate has a single symbolic param `theta`
      - a `RX(sympy.sympify("theta * alpha"))` gate has a single symbolic expression
          param `theta*alpha`

      We need it for translations to other frameworks and for serialization.


   .. py:method:: controlled(num_control_qubits: int) -> ControlledGate


   .. py:method:: dagger() -> ControlledGate
      :property:


   .. py:method:: exp() -> Gate
      :property:

      Gate representing the exponential of the given gate.


   .. py:method:: power(exponent: float) -> Gate

      Gate representing the underlying matrix raised to the power
      of the given exponent.


   .. py:method:: bind(symbols_map) -> Gate


   .. py:method:: replace_params(new_params: Tuple[quantum.circuits._operations.Parameter, Ellipsis]) -> Gate



.. py:data:: DAGGER_GATE_NAME
   :annotation: = Dagger

   

.. py:class:: Dagger

   Bases: :py:obj:`Gate`

   Interface of a quantum gate representable by a matrix, translatable to other
   frameworks and backends.

   See `orquestra.quantum.circuits` for a list of built-in gates and usage guide.

   .. py:attribute:: wrapped_gate
      :annotation: :Gate

      

   .. py:method:: matrix() -> sympy.Matrix
      :property:

      Unitary matrix describing gate's action on state vector.

      We need it to be able to implement .propagate() on the operation class.


   .. py:method:: params() -> Tuple[quantum.circuits._operations.Parameter, Ellipsis]
      :property:

      Value of parameters bound to this gate.

      Length of `params` should be equal to number of parameters in gate initializer.
      In particular, nonparametric gates should always return ().

      Examples:
      - an `H` gate has no params
      - a `RX(np.pi)` gate has a single param with value of `np.pi`
      - a `RX(sympy.Symbol("theta"))` gate has a single symbolic param `theta`
      - a `RX(sympy.sympify("theta * alpha"))` gate has a single symbolic expression
          param `theta*alpha`

      We need it for translations to other frameworks and for serialization.


   .. py:method:: num_qubits() -> int
      :property:

      Number of qubits this gate acts on.
      We need it because matrix is computed lazily, and we don't want to create matrix
      just to know the number of qubits.


   .. py:method:: name()
      :property:

      Globally unique name of the gate.

      Name is used in textual representation and dispatching in conversion between
      frameworks. Defining different gates with the same name as built-in ones
      is discouraged.


   .. py:method:: controlled(num_control_qubits: int) -> Gate


   .. py:method:: bind(symbols_map) -> Gate


   .. py:method:: replace_params(new_params: Tuple[quantum.circuits._operations.Parameter, Ellipsis]) -> Gate


   .. py:method:: dagger() -> Gate
      :property:


   .. py:method:: exp() -> Gate
      :property:

      Gate representing the exponential of the given gate.


   .. py:method:: power(exponent: float) -> Gate

      Gate representing the underlying matrix raised to the power
      of the given exponent.



.. py:data:: EXPONENTIAL_GATE_NAME
   :annotation: = Exponential

   

.. py:class:: Exponential

   Bases: :py:obj:`Gate`

   Interface of a quantum gate representable by a matrix, translatable to other
   frameworks and backends.

   See `orquestra.quantum.circuits` for a list of built-in gates and usage guide.

   .. py:attribute:: wrapped_gate
      :annotation: :Gate

      

   .. py:method:: matrix() -> sympy.Matrix
      :property:

      Unitary matrix describing gate's action on state vector.

      We need it to be able to implement .propagate() on the operation class.


   .. py:method:: params() -> Tuple[quantum.circuits._operations.Parameter, Ellipsis]
      :property:

      Value of parameters bound to this gate.

      Length of `params` should be equal to number of parameters in gate initializer.
      In particular, nonparametric gates should always return ().

      Examples:
      - an `H` gate has no params
      - a `RX(np.pi)` gate has a single param with value of `np.pi`
      - a `RX(sympy.Symbol("theta"))` gate has a single symbolic param `theta`
      - a `RX(sympy.sympify("theta * alpha"))` gate has a single symbolic expression
          param `theta*alpha`

      We need it for translations to other frameworks and for serialization.


   .. py:method:: num_qubits() -> int
      :property:

      Number of qubits this gate acts on.
      We need it because matrix is computed lazily, and we don't want to create matrix
      just to know the number of qubits.


   .. py:method:: name()
      :property:

      Globally unique name of the gate.

      Name is used in textual representation and dispatching in conversion between
      frameworks. Defining different gates with the same name as built-in ones
      is discouraged.


   .. py:method:: controlled(num_control_qubits: int) -> Gate


   .. py:method:: bind(symbols_map) -> Gate
      :abstractmethod:


   .. py:method:: replace_params(new_params: Tuple[quantum.circuits._operations.Parameter, Ellipsis]) -> Gate


   .. py:method:: dagger() -> Gate
      :property:


   .. py:method:: exp() -> Gate
      :property:

      Gate representing the exponential of the given gate.


   .. py:method:: power(exponent: float) -> Gate

      Gate representing the underlying matrix raised to the power
      of the given exponent.



.. py:data:: POWER_GATE_SYMBOL
   :annotation: = ^

   

.. py:class:: Power

   Bases: :py:obj:`Gate`

   Interface of a quantum gate representable by a matrix, translatable to other
   frameworks and backends.

   See `orquestra.quantum.circuits` for a list of built-in gates and usage guide.

   .. py:attribute:: wrapped_gate
      :annotation: :Gate

      

   .. py:attribute:: exponent
      :annotation: :float

      

   .. py:method:: name() -> str
      :property:

      Globally unique name of the gate.

      Name is used in textual representation and dispatching in conversion between
      frameworks. Defining different gates with the same name as built-in ones
      is discouraged.


   .. py:method:: params() -> Tuple[quantum.circuits._operations.Parameter, Ellipsis]
      :property:

      Value of parameters bound to this gate.

      Length of `params` should be equal to number of parameters in gate initializer.
      In particular, nonparametric gates should always return ().

      Examples:
      - an `H` gate has no params
      - a `RX(np.pi)` gate has a single param with value of `np.pi`
      - a `RX(sympy.Symbol("theta"))` gate has a single symbolic param `theta`
      - a `RX(sympy.sympify("theta * alpha"))` gate has a single symbolic expression
          param `theta*alpha`

      We need it for translations to other frameworks and for serialization.


   .. py:method:: free_symbols() -> Iterable[sympy.Symbol]
      :property:

      Unbound symbols in the gate matrix.

      Examples:
      - an `H` gate has no free symbols
      - a `RX(np.pi)` gate has no free symbols
      - a `RX(sympy.Symbol("theta"))` gate has a single free symbol `theta`
      - a `RX(sympy.sympify("theta * alpha"))` gate has two free symbols, `alpha` and
          `theta`
      - a `RX(sympy.sympify("theta * alpha")).bind({sympy.Symbol("theta"): 0.42})`
          gate has one free symbol, `alpha`


   .. py:method:: num_qubits() -> int
      :property:

      Number of qubits this gate acts on.
      We need it because matrix is computed lazily, and we don't want to create matrix
      just to know the number of qubits.


   .. py:method:: matrix() -> sympy.Matrix
      :property:

      Unitary matrix describing gate's action on state vector.

      We need it to be able to implement .propagate() on the operation class.


   .. py:method:: controlled(num_control_qubits: int) -> Gate


   .. py:method:: dagger() -> Gate
      :property:


   .. py:method:: exp() -> Gate
      :property:

      Gate representing the exponential of the given gate.


   .. py:method:: power(exponent: float) -> Gate

      Gate representing the underlying matrix raised to the power
      of the given exponent.


   .. py:method:: bind(symbols_map: Dict[sympy.Symbol, quantum.circuits._operations.Parameter]) -> Gate
      :abstractmethod:


   .. py:method:: replace_params(new_params: Tuple[quantum.circuits._operations.Parameter, Ellipsis]) -> Gate



.. py:class:: CustomGateMatrixFactory

   Can be passed as `matrix_factory` when a gate matrix isn't lazily evaluated.

   .. py:attribute:: gate_definition
      :annotation: :CustomGateDefinition

      

   .. py:method:: matrix() -> sympy.Matrix
      :property:


   .. py:method:: params_ordering() -> Tuple[quantum.circuits._operations.Parameter, Ellipsis]
      :property:



.. py:class:: CustomGateDefinition

   Use this class to define a non-built-in gate.

   See "Defining new gates" section in `help(orquestra.quantum.circuits)` for
   usage guide.

   User-defined gates are treated differently than the built-in ones,
   because the built-in ones are defined in `orquestra.quantum` library, and so
   we can assume that the definitions will be available during circuit deserialization.

   User-provided gates can be defined in one repo (e.g. Orquestra step), serialized,
   and passed to another project for deserialization. The other project must have
   access to gate details, e.g. the gate matrix. This class is designed to keep track
   of the gate details needed for deserialization.

   Instances of this class are serialized by the Circuit objects, additionally to
   Circuit operations.

   .. py:attribute:: gate_name
      :annotation: :str

      

   .. py:attribute:: matrix
      :annotation: :sympy.Matrix

      

   .. py:attribute:: params_ordering
      :annotation: :Tuple[sympy.Symbol, Ellipsis]

      


