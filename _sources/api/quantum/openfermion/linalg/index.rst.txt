:py:mod:`quantum.openfermion.linalg`
====================================

.. py:module:: quantum.openfermion.linalg


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   sparse_tools/index.rst


Package Contents
----------------


Functions
~~~~~~~~~

.. autoapisummary::

   quantum.openfermion.linalg.eigenspectrum
   quantum.openfermion.linalg.expectation
   quantum.openfermion.linalg.get_density_matrix
   quantum.openfermion.linalg.get_ground_state
   quantum.openfermion.linalg.get_number_preserving_sparse_operator
   quantum.openfermion.linalg.get_sparse_operator
   quantum.openfermion.linalg.inner_product
   quantum.openfermion.linalg.jordan_wigner_ladder_sparse
   quantum.openfermion.linalg.jordan_wigner_sparse
   quantum.openfermion.linalg.jw_configuration_state
   quantum.openfermion.linalg.jw_get_ground_state_at_particle_number
   quantum.openfermion.linalg.jw_hartree_fock_state
   quantum.openfermion.linalg.jw_number_indices
   quantum.openfermion.linalg.jw_number_restrict_operator
   quantum.openfermion.linalg.kronecker_operators
   quantum.openfermion.linalg.qubit_operator_sparse
   quantum.openfermion.linalg.sparse_eigenspectrum
   quantum.openfermion.linalg.wrapped_kronecker



.. py:function:: eigenspectrum(operator, n_qubits=None)

   Compute the eigenspectrum of an operator.

   WARNING: This function has cubic runtime in dimension of
       Hilbert space operator, which might be exponential.

   NOTE: This function does not currently support
       QuadOperator and BosonOperator.

   :param operator: QubitOperator, InteractionOperator, FermionOperator,
                    PolynomialTensor, or InteractionRDM.
   :param n_qubits: number of qubits/modes in operator. if None, will
                    be counted.
   :type n_qubits: int

   :returns: dense numpy array of floats giving eigenspectrum.
   :rtype: spectrum


.. py:function:: expectation(operator, state)

   Compute the expectation value of an operator with a state.

   :param operator: The operator whose expectation value is desired.
   :type operator: scipy.sparse.spmatrix or scipy.sparse.linalg.LinearOperator
   :param state: A numpy array
                 representing a pure state or a sparse matrix representing a density
                 matrix. If `operator` is a LinearOperator, then this must be a
                 numpy array.
   :type state: numpy.ndarray or scipy.sparse.spmatrix

   :returns: A complex number giving the expectation value.

   :raises ValueError: Input state has invalid format.


.. py:function:: get_density_matrix(states, probabilities)


.. py:function:: get_ground_state(sparse_operator, initial_guess=None)

   Compute lowest eigenvalue and eigenstate.

   :param sparse_operator: Operator to find the ground state of.
   :type sparse_operator: LinearOperator
   :param initial_guess: Initial guess for ground state.  A good
                         guess dramatically reduces the cost required to converge.
   :type initial_guess: ndarray

   :returns: * *eigenvalue* -- The lowest eigenvalue, a float.
             * *eigenstate* -- The lowest eigenstate in scipy.sparse csc format.


.. py:function:: get_number_preserving_sparse_operator(fermion_op, num_qubits, num_electrons, spin_preserving=False, reference_determinant=None, excitation_level=None)

   Initialize a Scipy sparse matrix in a specific symmetry sector.

   This method initializes a Scipy sparse matrix from a FermionOperator,
   explicitly working in a particular particle number sector. Optionally, it
   can also restrict the space to contain only states with a particular Sz.

   Finally, the Hilbert space can also be restricted to only those states
   which are reachable by excitations up to a fixed rank from an initial
   reference determinant.

   :param fermion_op: An instance of the FermionOperator class.
                      It should not contain terms which do not preserve particle number.
                      If spin_preserving is set to True it should also not contain terms
                      which do not preserve the Sz (it is assumed that the ordering of
                      the indices goes alpha, beta, alpha, beta, ...).
   :type fermion_op: FermionOperator
   :param num_qubits: The total number of qubits / spin-orbitals in the
                      system.
   :type num_qubits: int
   :param num_electrons: The number of particles in the desired Hilbert
                         space.
   :type num_electrons: int
   :param spin_preserving: Whether or not the constructed operator should
                           be defined in a space which has support only on states with the
                           same Sz value as the reference_determinant.
   :type spin_preserving: bool
   :param reference_determinant: A list, whose length is equal to
                                 num_qubits, which specifies which orbitals should be occupied in
                                 the reference state. If spin_preserving is set to True then the Sz
                                 value of this reference state determines the Sz value of the
                                 symmetry sector in which the generated operator acts. If a value
                                 for excitation_level is provided then the excitations are generated
                                 with respect to the reference state. In any case, the ordering of
                                 the states in the matrix representation of the operator depends on
                                 reference_determinant and the state corresponding to
                                 reference_determinant is the vector [1.0, 0.0, 0.0 ... 0.0]. Can be
                                 set to None in order to take the first num_electrons orbitals to be
                                 the occupied orbitals.
   :type reference_determinant: list(bool)
   :param excitation_level: The number of excitations from the reference
                            state which should be included in the generated operator's matrix
                            representation. Can be set to None to include all levels of
                            excitation.
   :type excitation_level: int

   :returns:

             A sparse matrix representation of
                 fermion_op in the basis set by the arguments.
   :rtype: sparse_op(scipy.sparse.csc_matrix)


.. py:function:: get_sparse_operator(operator, n_qubits=None, trunc=None, hbar=1.0)

   Map an operator to a sparse matrix.

   If the input is not a QubitOperator, the Jordan-Wigner Transform is used.

   :param operator: Currently supported operators include:
                    FermionOperator, QubitOperator, PolynomialTensor.
   :param n_qubits: Number qubits in the system Hilbert space.
                    Applicable only to fermionic systems.
   :type n_qubits: int
   :param trunc: The size at which the Fock space should be truncated.
                 Applicable only to bosonic systems.
   :type trunc: int
   :param hbar: the value of hbar to use in the definition of the
                canonical commutation relation [q_i, p_j] = \delta_{ij} i hbar.
                Applicable only to the QuadOperator.
   :type hbar: float


.. py:function:: inner_product(state_1, state_2)

   Compute inner product of two states.


.. py:function:: jordan_wigner_ladder_sparse(n_qubits, tensor_factor, ladder_type)

   Make a matrix representation of a fermion ladder operator.

   Operators are mapped as follows:
   a_j^\dagger -> Z_0 .. Z_{j-1} (X_j - iY_j) / 2
   a_j -> Z_0 .. Z_{j-1} (X_j + iY_j) / 2

   :param index: This is a nonzero integer. The integer indicates the tensor
                 factor and the sign indicates raising or lowering.
   :param n_qubits: Number qubits in the system Hilbert space.
   :type n_qubits: int

   :returns: The corresponding Scipy sparse matrix.


.. py:function:: jordan_wigner_sparse(fermion_operator, n_qubits=None)

   Initialize a Scipy sparse matrix from a FermionOperator.

   Operators are mapped as follows:
   a_j^\dagger -> Z_0 .. Z_{j-1} (X_j - iY_j) / 2
   a_j -> Z_0 .. Z_{j-1} (X_j + iY_j) / 2

   :param fermion_operator: instance of the FermionOperator
                            class.
   :type fermion_operator: FermionOperator
   :param n_qubits: Number of qubits.
   :type n_qubits: int

   :returns: The corresponding Scipy sparse matrix.


.. py:function:: jw_configuration_state(occupied_orbitals, n_qubits)

   Function to produce a basis state in the occupation number basis.

   :param occupied_orbitals: A list of integers representing the indices
                             of the occupied orbitals in the desired basis state
   :type occupied_orbitals: list
   :param n_qubits: The total number of qubits
   :type n_qubits: int

   :returns: The basis state as a sparse matrix
   :rtype: basis_vector(sparse)


.. py:function:: jw_get_ground_state_at_particle_number(sparse_operator, particle_number)

   Compute ground energy and state at a specified particle number.

   Assumes the Jordan-Wigner transform. The input operator should be Hermitian
   and particle-number-conserving.

   :param sparse_operator: A Jordan-Wigner encoded sparse matrix.
   :type sparse_operator: sparse
   :param particle_number: The particle number at which to compute the ground
                           energy and states
   :type particle_number: int

   :returns:

             The lowest eigenvalue of sparse_operator within
                 the eigenspace of the number operator corresponding to
                 particle_number.
             ground_state(ndarray): The ground state at the particle number
   :rtype: ground_energy(float)


.. py:function:: jw_hartree_fock_state(n_electrons, n_orbitals)

   Function to produce Hartree-Fock state in JW representation.


.. py:function:: jw_number_indices(n_electrons, n_qubits)

   Return the indices for n_electrons in n_qubits under JW encoding

   Calculates the indices for all possible arrangements of n-electrons
       within n-qubit orbitals when a Jordan-Wigner encoding is used.
       Useful for restricting generic operators or vectors to a particular
       particle number space when desired

   :param n_electrons: Number of particles to restrict the operator to
   :type n_electrons: int
   :param n_qubits: Number of qubits defining the total state
   :type n_qubits: int

   :returns:

             List of indices in a 2^n length array that indicate
                 the indices of constant particle number within n_qubits
                 in a Jordan-Wigner encoding.
   :rtype: indices(list)


.. py:function:: jw_number_restrict_operator(operator, n_electrons, n_qubits=None)

   Restrict a Jordan-Wigner encoded operator to a given particle number

   :param sparse_operator: Numpy operator acting on
                           the space of n_qubits.
   :type sparse_operator: ndarray or sparse
   :param n_electrons: Number of particles to restrict the operator to
   :type n_electrons: int
   :param n_qubits: Number of qubits defining the total state
   :type n_qubits: int

   :returns:

             Numpy operator restricted to
                 acting on states with the same particle number.
   :rtype: new_operator(ndarray or sparse)


.. py:function:: kronecker_operators(*args)

   Return the Kronecker product of multiple sparse.csc_matrix operators.


.. py:function:: qubit_operator_sparse(qubit_operator: orquestra.quantum.openfermion.ops.operators.QubitOperator, n_qubits=None)

   Initialize a Scipy sparse matrix from a QubitOperator.

   :param qubit_operator: instance of the QubitOperator class.
   :type qubit_operator: QubitOperator
   :param n_qubits: Number of qubits.
   :type n_qubits: int

   :returns: The corresponding Scipy sparse matrix.


.. py:function:: sparse_eigenspectrum(sparse_operator)

   Perform a dense diagonalization.

   :returns: The lowest eigenvalues in a numpy array.
   :rtype: eigenspectrum


.. py:function:: wrapped_kronecker(operator_1, operator_2)

   Return the Kronecker product of two sparse.csc_matrix operators.


