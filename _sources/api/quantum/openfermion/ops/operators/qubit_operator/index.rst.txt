:py:mod:`quantum.openfermion.ops.operators.qubit_operator`
==========================================================

.. py:module:: quantum.openfermion.ops.operators.qubit_operator

.. autoapi-nested-parse::

   QubitOperator stores a sum of Pauli operators acting on qubits.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   quantum.openfermion.ops.operators.qubit_operator.QubitOperator




.. py:class:: QubitOperator

   Bases: :py:obj:`orquestra.quantum.openfermion.ops.operators.symbolic_operator.SymbolicOperator`

   A sum of terms acting on qubits, e.g., 0.5 * 'X0 X5' + 0.3 * 'Z1 Z2'.

   A term is an operator acting on n qubits and can be represented as:

   coefficient * local_operator[0] x ... x local_operator[n-1]

   where x is the tensor product. A local operator is a Pauli operator
   ('I', 'X', 'Y', or 'Z') which acts on one qubit. In math notation a term
   is, for example, 0.5 * 'X0 X5', which means that a Pauli X operator acts
   on qubit 0 and 5, while the identity operator acts on all other qubits.

   A QubitOperator represents a sum of terms acting on qubits and overloads
   operations for easy manipulation of these objects by the user.

   Note for a QubitOperator to be a Hamiltonian which is a hermitian
   operator, the coefficients of all terms must be real.

   .. code-block:: python

       hamiltonian = 0.5 * QubitOperator('X0 X5') + 0.3 * QubitOperator('Z0')

   QubitOperator is a subclass of SymbolicOperator. Importantly, it has
   attributes set as follows::

       actions = ('X', 'Y', 'Z')
       action_strings = ('X', 'Y', 'Z')
       action_before_index = True
       different_indices_commute = True

   See the documentation of SymbolicOperator for more details.

   .. rubric:: Example

   .. code-block:: python

       ham = ((QubitOperator('X0 Y3', 0.5)
               + 0.6 * QubitOperator('X0 Y3')))
       # Equivalently
       ham2 = QubitOperator('X0 Y3', 0.5)
       ham2 += 0.6 * QubitOperator('X0 Y3')

   .. note::

      Adding QubitOperators is faster using += (as this
      is done by in-place addition). Specifying the coefficient
      during initialization is faster than multiplying a QubitOperator
      with a scalar.

   .. py:method:: actions()
      :property:

      The allowed actions.


   .. py:method:: action_strings()
      :property:

      The string representations of the allowed actions.


   .. py:method:: action_before_index()
      :property:

      Whether action comes before index in string representations.


   .. py:method:: different_indices_commute()
      :property:

      Whether factors acting on different indices commute.


   .. py:method:: renormalize()

      Fix the trace norm of an operator to 1



