:py:mod:`quantum.openfermion.ops.operators.symbolic_operator`
=============================================================

.. py:module:: quantum.openfermion.ops.operators.symbolic_operator

.. autoapi-nested-parse::

   SymbolicOperator is the base class for FermionOperator and QubitOperator



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   quantum.openfermion.ops.operators.symbolic_operator.SymbolicOperator




Attributes
~~~~~~~~~~

.. autoapisummary::

   quantum.openfermion.ops.operators.symbolic_operator.COEFFICIENT_TYPES


.. py:data:: COEFFICIENT_TYPES
   

   

.. py:class:: SymbolicOperator(term=None, coefficient=1.0)

   Base class for FermionOperator and QubitOperator.

   A SymbolicOperator stores an object which represents a weighted
   sum of terms; each term is a product of individual factors
   of the form (`index`, `action`), where `index` is a nonnegative integer
   and the possible values for `action` are determined by the subclass.
   For instance, for the subclass FermionOperator, `action` can be 1 or 0,
   indicating raising or lowering, and for QubitOperator, `action` is from
   the set {'X', 'Y', 'Z'}.
   The coefficients of the terms are stored in a dictionary whose
   keys are the terms.
   SymbolicOperators of the same type can be added or multiplied together.

   .. note::

      Adding SymbolicOperators is faster using += (as this
      is done by in-place addition). Specifying the coefficient
      during initialization is faster than multiplying a SymbolicOperator
      with a scalar.

   .. attribute:: actions

      A tuple of objects representing the possible actions.
      e.g. for FermionOperator, this is (1, 0).

      :type: tuple

   .. attribute:: action_strings

      A tuple of string representations of actions.
      These should be in one-to-one correspondence with actions and
      listed in the same order.
      e.g. for FermionOperator, this is ('^', '').

      :type: tuple

   .. attribute:: action_before_index

      A boolean indicating whether in string
      representations, the action should come before the index.

      :type: bool

   .. attribute:: different_indices_commute

      A boolean indicating whether
      factors acting on different indices commute.

      :type: bool

   .. attribute:: terms

      **key** (tuple of tuples): A dictionary storing the coefficients
      of the terms in the operator. The keys are the terms.
      A term is a product of individual factors; each factor is
      represented by a tuple of the form (`index`, `action`), and
      these tuples are collected into a larger tuple which represents
      the term as the product of its factors.

      :type: dict

   .. py:method:: actions()
      :abstractmethod:

      The allowed actions.

      Returns a tuple of objects representing the possible actions.


   .. py:method:: action_strings()
      :abstractmethod:

      The string representations of the allowed actions.

      Returns a tuple containing string representations of the possible
      actions, in the same order as the `actions` property.


   .. py:method:: action_before_index()
      :abstractmethod:

      Whether action comes before index in string representations.

      Example: For QubitOperator, the actions are ('X', 'Y', 'Z') and
      the string representations look something like 'X0 Z2 Y3'. So the
      action comes before the index, and this function should return True.
      For FermionOperator, the string representations look like
      '0^ 1 2^ 3'. The action comes after the index, so this function
      should return False.


   .. py:method:: different_indices_commute()
      :abstractmethod:

      Whether factors acting on different indices commute.


   .. py:method:: constant()
      :property:

      The value of the constant term.


   .. py:method:: zero()
      :classmethod:

      :returns:     A symbolic operator o with the property that o+x = x+o = x for
                    all operators x of the same class.
      :rtype: additive_identity (SymbolicOperator)


   .. py:method:: identity()
      :classmethod:

      :returns:     A symbolic operator u with the property that u*x = x*u = x for
                    all operators x of the same class.
      :rtype: multiplicative_identity (SymbolicOperator)


   .. py:method:: isclose(other, tol=EQ_TOLERANCE)

      Check if other (SymbolicOperator) is close to self.

      Comparison is done for each term individually. Return True
      if the difference between each term in self and other is
      less than EQ_TOLERANCE

      :param other: SymbolicOperator to compare against.
      :type other: SymbolicOperator


   .. py:method:: compress(abs_tol=EQ_TOLERANCE)

      Eliminates all terms with coefficients close to zero and removes
      small imaginary and real parts.

      :param abs_tol: Absolute tolerance, must be at least 0.0
      :type abs_tol: float


   .. py:method:: induced_norm(order=1)

      Compute the induced p-norm of the operator.

      If we represent an operator as
      $\sum_{j} w_j H_j$
      where $w_j$ are scalar coefficients then this norm is
      $\left(\sum_{j} \| w_j \|^p \right)^{\frac{1}{p}}$
      where $p$ is the order of the induced norm

      :param order: the order of the induced norm.
      :type order: int


   .. py:method:: many_body_order()

      Compute the many-body order of a SymbolicOperator.

      The many-body order of a SymbolicOperator is the maximum length of
      a term with nonzero coefficient.

      :returns: int


   .. py:method:: accumulate(operators, start=None)
      :classmethod:

      Sums over SymbolicOperators.


   .. py:method:: get_operators()

      Gets a list of operators with a single term.

      :returns: A generator of the operators in self.
      :rtype: operators([self.__class__])


   .. py:method:: get_operator_groups(num_groups)

      Gets a list of operators with a few terms.
      :param num_groups: How many operators to get in the end.
      :type num_groups: int

      :returns:

                A list of operators summing up to
                    self.
      :rtype: operators([self.__class__])



