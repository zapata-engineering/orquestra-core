:orphan:

:py:mod:`quantum.operators._pauli_operators`
============================================

.. py:module:: quantum.operators._pauli_operators


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   quantum.operators._pauli_operators.PauliTerm
   quantum.operators._pauli_operators.PauliSum




Attributes
~~~~~~~~~~

.. autoapisummary::

   quantum.operators._pauli_operators.PauliRepresentation
   quantum.operators._pauli_operators.ALLOWED_OPERATORS
   quantum.operators._pauli_operators.OPERATOR_MAP
   quantum.operators._pauli_operators.COEFF_MAP
   quantum.operators._pauli_operators.HASH_PRECISION


.. py:data:: PauliRepresentation
   

   

.. py:data:: ALLOWED_OPERATORS
   :annotation: = ['X', 'Y', 'Z', 'I']

   

.. py:data:: OPERATOR_MAP
   

   

.. py:data:: COEFF_MAP
   

   

.. py:data:: HASH_PRECISION
   :annotation: = 1000000.0

   

.. py:class:: PauliTerm(operator: Union[str, Dict[int, str]], coefficient: Optional[complex] = None)

   Representation of a single Pauli Term.

   If coefficient is not provided neither directly nor in the string repr,
   it defaults to 1.0

   .. py:method:: from_iterable(terms: Iterable[Tuple[str, int]], coefficient: complex = 1.0) -> PauliTerm
      :staticmethod:

      Construct PauliTerm from a list of operators.

      A slightly more efficient constructor when all the elements of the term are
      known beforehand. Users should employ this function instead of creating
      individual terms and multiplying.


   .. py:method:: identity() -> PauliTerm
      :staticmethod:


   .. py:method:: copy(new_coefficient: complex = None) -> PauliTerm

      Copy PauliTerm, possibly changing its coefficient to a new one.

      The created copy is deep, in particular internal dictionary storing map
      from qubit indices to operators is also copied.


   .. py:method:: qubits() -> Set[int]
      :property:

      The list of qubit indices associated with this term.


   .. py:method:: is_ising() -> bool
      :property:

      True iff this term is Ising Operator (i.e. contains no X or Y operators)


   .. py:method:: circuit() -> orquestra.quantum.circuits.Circuit
      :property:

      Circuit implementing this Pauli term.

      For efficiency constructed circuit is cached after the first invocation of
      this property.


   .. py:method:: operations() -> FrozenSet[Tuple[int, str]]
      :property:


   .. py:method:: terms() -> List[PauliTerm]
      :property:


   .. py:method:: is_constant() -> bool
      :property:


   .. py:method:: n_qubits() -> int
      :property:

      Number of qubits used in this PauliTerm.

      Follows the convention of openfermion's `count_qubits`.
      Note that this is different from the number of operations. For example,
      PauliTerm("Z0*Z3").n_qubits = 4, but len(PauliTerm("Z0*Z3").qubits) = 2.




.. py:class:: PauliSum(terms: Union[str, Sequence[PauliTerm]] = None)

   .. py:method:: qubits() -> Set[int]
      :property:


   .. py:method:: is_ising() -> bool
      :property:

      Returns whether the full operator represents an Ising model.


   .. py:method:: circuits() -> List[orquestra.quantum.circuits.Circuit]
      :property:


   .. py:method:: identity() -> PauliSum
      :staticmethod:


   .. py:method:: simplify() -> PauliSum


   .. py:method:: is_constant() -> bool
      :property:


   .. py:method:: n_qubits() -> int
      :property:

      Number of qubits used in this PauliSum.

      Follows the convention of openfermion's `count_qubits`, so that a qubit is
      counted even if there are no operations on it. For example,
      PauliSum("Z0+Z3").n_qubits = 4, but len(PauliSum("Z0+Z3").qubits) = 2.




