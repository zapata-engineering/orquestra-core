:py:mod:`quantum.typing`
========================

.. py:module:: quantum.typing

.. autoapi-nested-parse::

   Types commonly encountered in orquestra repositories.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   quantum.typing.Readable
   quantum.typing.Writeable
   quantum.typing.SupportsLessThan




Attributes
~~~~~~~~~~

.. autoapisummary::

   quantum.typing.AnyPath
   quantum.typing.LoadSource
   quantum.typing.DumpTarget
   quantum.typing.Specs
   quantum.typing.Parameter
   quantum.typing.ParameterizedVector


.. py:class:: Readable

   Bases: :py:obj:`Protocol`

   Base class for protocol classes.

   Protocol classes are defined as::

       class Proto(Protocol):
           def meth(self) -> int:
               ...

   Such classes are primarily used with static type checkers that recognize
   structural subtyping (static duck-typing), for example::

       class C:
           def meth(self) -> int:
               return 0

       def func(x: Proto) -> int:
           return x.meth()

       func(C())  # Passes static type check

   See PEP 544 for details. Protocol classes decorated with
   @typing.runtime_checkable act as simple-minded runtime protocols that check
   only the presence of given attributes, ignoring their type signatures.
   Protocol classes can be generic, they are defined as::

       class GenProto(Protocol[T]):
           def meth(self) -> T:
               ...

   .. py:method:: read(self, size: int = 0) -> str


   .. py:method:: writable(self) -> bool



.. py:class:: Writeable

   Bases: :py:obj:`Protocol`

   Base class for protocol classes.

   Protocol classes are defined as::

       class Proto(Protocol):
           def meth(self) -> int:
               ...

   Such classes are primarily used with static type checkers that recognize
   structural subtyping (static duck-typing), for example::

       class C:
           def meth(self) -> int:
               return 0

       def func(x: Proto) -> int:
           return x.meth()

       func(C())  # Passes static type check

   See PEP 544 for details. Protocol classes decorated with
   @typing.runtime_checkable act as simple-minded runtime protocols that check
   only the presence of given attributes, ignoring their type signatures.
   Protocol classes can be generic, they are defined as::

       class GenProto(Protocol[T]):
           def meth(self) -> T:
               ...

   .. py:method:: write(self, content: str)


   .. py:method:: writable(self) -> bool



.. py:data:: AnyPath
   

   

.. py:data:: LoadSource
   

   

.. py:data:: DumpTarget
   

   

.. py:data:: Specs
   

   

.. py:data:: Parameter
   

   

.. py:data:: ParameterizedVector
   

   

.. py:class:: SupportsLessThan

   Bases: :py:obj:`Protocol`

   Base class for protocol classes.

   Protocol classes are defined as::

       class Proto(Protocol):
           def meth(self) -> int:
               ...

   Such classes are primarily used with static type checkers that recognize
   structural subtyping (static duck-typing), for example::

       class C:
           def meth(self) -> int:
               return 0

       def func(x: Proto) -> int:
           return x.meth()

       func(C())  # Passes static type check

   See PEP 544 for details. Protocol classes decorated with
   @typing.runtime_checkable act as simple-minded runtime protocols that check
   only the presence of given attributes, ignoring their type signatures.
   Protocol classes can be generic, they are defined as::

       class GenProto(Protocol[T]):
           def meth(self) -> T:
               ...


