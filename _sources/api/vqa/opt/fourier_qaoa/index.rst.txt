:py:mod:`vqa.opt.fourier_qaoa`
==============================

.. py:module:: vqa.opt.fourier_qaoa


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   vqa.opt.fourier_qaoa.FourierOptimizer



Functions
~~~~~~~~~

.. autoapisummary::

   vqa.opt.fourier_qaoa.convert_u_v_to_gamma_beta



.. py:class:: FourierOptimizer(ansatz: orquestra.vqa.api.ansatz.Ansatz, inner_optimizer: orquestra.opt.api.optimizer.Optimizer, min_layer: int, max_layer: int, n_layers_per_iteration: int = 1, q: Optional[int] = None, R: int = 10, recorder: orquestra.opt.history.recorder.RecorderFactory = _recorder)

   Bases: :py:obj:`orquestra.opt.api.optimizer.NestedOptimizer`

   .. py:method:: inner_optimizer(self) -> orquestra.opt.api.optimizer.Optimizer
      :property:


   .. py:method:: recorder(self) -> orquestra.opt.history.recorder.RecorderFactory
      :property:



.. py:function:: convert_u_v_to_gamma_beta(n_layers: int, u_v: numpy.ndarray) -> numpy.ndarray

   Performs a "Discrete Sine/Cosine Transform" to convert u and v parameters into
   gamma and beta, as part of the FOURIER method for initializing QAOA parameters from
   https://arxiv.org/abs/1812.01041. See equation B2 of the original paper for how this
   is done.

   :param n layers is for size of output gamma/beta params.:
   :param u_v: parameters u and v in a 1d array with `u` ordered before `v`

   :returns: parameters gamma and beta in a 1d array of size `2 * n_layers`


