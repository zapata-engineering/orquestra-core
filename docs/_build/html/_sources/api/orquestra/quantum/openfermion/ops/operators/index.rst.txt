:py:mod:`orquestra.quantum.openfermion.ops.operators`
=====================================================

.. py:module:: orquestra.quantum.openfermion.ops.operators


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   fermion_operator/index.rst
   ising_operator/index.rst
   qubit_operator/index.rst
   symbolic_operator/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   orquestra.quantum.openfermion.ops.operators.FermionOperator
   orquestra.quantum.openfermion.ops.operators.IsingOperator
   orquestra.quantum.openfermion.ops.operators.QubitOperator
   orquestra.quantum.openfermion.ops.operators.SymbolicOperator




.. py:class:: FermionOperator(term=None, coefficient=1.0)

   Bases: :py:obj:`orquestra.quantum.openfermion.ops.operators.symbolic_operator.SymbolicOperator`

   FermionOperator stores a sum of products of fermionic ladder operators.

   In OpenFermion, we describe fermionic ladder operators using the shorthand:
   'q^' = a^\dagger_q
   'q' = a_q
   where {'p^', 'q'} = delta_pq

   One can multiply together these fermionic ladder operators to obtain a
   fermionic term. For instance, '2^ 1' is a fermion term which
   creates at orbital 2 and destroys at orbital 1. The FermionOperator class
   also stores a coefficient for the term, e.g. '3.17 * 2^ 1'.

   The FermionOperator class is designed (in general) to store sums of these
   terms. For instance, an instance of FermionOperator might represent
   3.17 2^ 1 - 66.2 * 8^ 7 6^ 2
   The Fermion Operator class overloads operations for manipulation of
   these objects by the user.

   FermionOperator is a subclass of SymbolicOperator. Importantly, it has
   attributes set as follows::

       actions = (1, 0)
       action_strings = ('^', '')
       action_before_index = False
       different_indices_commute = False

   See the documentation of SymbolicOperator for more details.

   .. rubric:: Example

   .. code-block:: python

       ham = (FermionOperator('0^ 3', .5)
              + .5 * FermionOperator('3^ 0'))
       # Equivalently
       ham2 = FermionOperator('0^ 3', 0.5)
       ham2 += FermionOperator('3^ 0', 0.5)

   .. note::

      Adding FermionOperators is faster using += (as this
      is done by in-place addition). Specifying the coefficient
      during initialization is faster than multiplying a FermionOperator
      with a scalar.

   .. py:method:: actions(self)
      :property:

      The allowed actions.


   .. py:method:: action_strings(self)
      :property:

      The string representations of the allowed actions.


   .. py:method:: action_before_index(self)
      :property:

      Whether action comes before index in string representations.


   .. py:method:: different_indices_commute(self)
      :property:

      Whether factors acting on different indices commute.


   .. py:method:: is_normal_ordered(self)

      Return whether or not term is in normal order.

      In our convention, normal ordering implies terms are ordered
      from highest tensor factor (on left) to lowest (on right). Also,
      ladder operators come first.


   .. py:method:: is_two_body_number_conserving(self, check_spin_symmetry=False)

      Query whether operator has correct form to be from a molecule.

      Require that term is particle-number conserving (same number of
      raising and lowering operators). Require that term has 0, 2 or 4
      ladder operators. Require that term conserves spin (parity of
      raising operators equals parity of lowering operators).

      :param check_spin_symmetry: Whether to check if
                                  operator conserves spin.
      :type check_spin_symmetry: bool



.. py:class:: IsingOperator(term=None, coefficient=1.0)

   Bases: :py:obj:`orquestra.quantum.openfermion.ops.operators.symbolic_operator.SymbolicOperator`

   The IsingOperator class provides an analytic representation of an
   Ising-type Hamiltonian, i.e. a sum of product of Zs.

   IsingOperator is a subclass of SymbolicOperator. Importantly, it has
   attributes set as follows:

       actions = ('Z')
       action_strings = ('Z')
       action_before_index = True
       different_indices_commute = True

   See the documentation of SymbolicOperator for more details.

   .. py:method:: actions(self)
      :property:

      The allowed actions.


   .. py:method:: action_strings(self)
      :property:

      The string representations of the allowed actions.


   .. py:method:: action_before_index(self)
      :property:

      Whether action comes before index in string representations.


   .. py:method:: different_indices_commute(self)
      :property:

      Whether factors acting on different indices commute.



.. py:class:: QubitOperator(term=None, coefficient=1.0)

   Bases: :py:obj:`orquestra.quantum.openfermion.ops.operators.symbolic_operator.SymbolicOperator`

   A sum of terms acting on qubits, e.g., 0.5 * 'X0 X5' + 0.3 * 'Z1 Z2'.

   A term is an operator acting on n qubits and can be represented as:

   coefficient * local_operator[0] x ... x local_operator[n-1]

   where x is the tensor product. A local operator is a Pauli operator
   ('I', 'X', 'Y', or 'Z') which acts on one qubit. In math notation a term
   is, for example, 0.5 * 'X0 X5', which means that a Pauli X operator acts
   on qubit 0 and 5, while the identity operator acts on all other qubits.

   A QubitOperator represents a sum of terms acting on qubits and overloads
   operations for easy manipulation of these objects by the user.

   Note for a QubitOperator to be a Hamiltonian which is a hermitian
   operator, the coefficients of all terms must be real.

   .. code-block:: python

       hamiltonian = 0.5 * QubitOperator('X0 X5') + 0.3 * QubitOperator('Z0')

   QubitOperator is a subclass of SymbolicOperator. Importantly, it has
   attributes set as follows::

       actions = ('X', 'Y', 'Z')
       action_strings = ('X', 'Y', 'Z')
       action_before_index = True
       different_indices_commute = True

   See the documentation of SymbolicOperator for more details.

   .. rubric:: Example

   .. code-block:: python

       ham = ((QubitOperator('X0 Y3', 0.5)
               + 0.6 * QubitOperator('X0 Y3')))
       # Equivalently
       ham2 = QubitOperator('X0 Y3', 0.5)
       ham2 += 0.6 * QubitOperator('X0 Y3')

   .. note::

      Adding QubitOperators is faster using += (as this
      is done by in-place addition). Specifying the coefficient
      during initialization is faster than multiplying a QubitOperator
      with a scalar.

   .. py:method:: actions(self)
      :property:

      The allowed actions.


   .. py:method:: action_strings(self)
      :property:

      The string representations of the allowed actions.


   .. py:method:: action_before_index(self)
      :property:

      Whether action comes before index in string representations.


   .. py:method:: different_indices_commute(self)
      :property:

      Whether factors acting on different indices commute.


   .. py:method:: renormalize(self)

      Fix the trace norm of an operator to 1



.. py:class:: SymbolicOperator(term=None, coefficient=1.0)

   Base class for FermionOperator and QubitOperator.

   A SymbolicOperator stores an object which represents a weighted
   sum of terms; each term is a product of individual factors
   of the form (`index`, `action`), where `index` is a nonnegative integer
   and the possible values for `action` are determined by the subclass.
   For instance, for the subclass FermionOperator, `action` can be 1 or 0,
   indicating raising or lowering, and for QubitOperator, `action` is from
   the set {'X', 'Y', 'Z'}.
   The coefficients of the terms are stored in a dictionary whose
   keys are the terms.
   SymbolicOperators of the same type can be added or multiplied together.

   .. note::

      Adding SymbolicOperators is faster using += (as this
      is done by in-place addition). Specifying the coefficient
      during initialization is faster than multiplying a SymbolicOperator
      with a scalar.

   .. attribute:: actions

      A tuple of objects representing the possible actions.
      e.g. for FermionOperator, this is (1, 0).

      :type: tuple

   .. attribute:: action_strings

      A tuple of string representations of actions.
      These should be in one-to-one correspondence with actions and
      listed in the same order.
      e.g. for FermionOperator, this is ('^', '').

      :type: tuple

   .. attribute:: action_before_index

      A boolean indicating whether in string
      representations, the action should come before the index.

      :type: bool

   .. attribute:: different_indices_commute

      A boolean indicating whether
      factors acting on different indices commute.

      :type: bool

   .. attribute:: terms

      **key** (tuple of tuples): A dictionary storing the coefficients
      of the terms in the operator. The keys are the terms.
      A term is a product of individual factors; each factor is
      represented by a tuple of the form (`index`, `action`), and
      these tuples are collected into a larger tuple which represents
      the term as the product of its factors.

      :type: dict

   .. py:method:: actions(self)
      :abstractmethod:

      The allowed actions.

      Returns a tuple of objects representing the possible actions.


   .. py:method:: action_strings(self)
      :abstractmethod:

      The string representations of the allowed actions.

      Returns a tuple containing string representations of the possible
      actions, in the same order as the `actions` property.


   .. py:method:: action_before_index(self)
      :abstractmethod:

      Whether action comes before index in string representations.

      Example: For QubitOperator, the actions are ('X', 'Y', 'Z') and
      the string representations look something like 'X0 Z2 Y3'. So the
      action comes before the index, and this function should return True.
      For FermionOperator, the string representations look like
      '0^ 1 2^ 3'. The action comes after the index, so this function
      should return False.


   .. py:method:: different_indices_commute(self)
      :abstractmethod:

      Whether factors acting on different indices commute.


   .. py:method:: constant(self)
      :property:

      The value of the constant term.


   .. py:method:: zero(cls)
      :classmethod:

      :returns:     A symbolic operator o with the property that o+x = x+o = x for
                    all operators x of the same class.
      :rtype: additive_identity (SymbolicOperator)


   .. py:method:: identity(cls)
      :classmethod:

      :returns:     A symbolic operator u with the property that u*x = x*u = x for
                    all operators x of the same class.
      :rtype: multiplicative_identity (SymbolicOperator)


   .. py:method:: isclose(self, other, tol=EQ_TOLERANCE)

      Check if other (SymbolicOperator) is close to self.

      Comparison is done for each term individually. Return True
      if the difference between each term in self and other is
      less than EQ_TOLERANCE

      :param other: SymbolicOperator to compare against.
      :type other: SymbolicOperator


   .. py:method:: compress(self, abs_tol=EQ_TOLERANCE)

      Eliminates all terms with coefficients close to zero and removes
      small imaginary and real parts.

      :param abs_tol: Absolute tolerance, must be at least 0.0
      :type abs_tol: float


   .. py:method:: induced_norm(self, order=1)

      Compute the induced p-norm of the operator.

      If we represent an operator as
      $\sum_{j} w_j H_j$
      where $w_j$ are scalar coefficients then this norm is
      $\left(\sum_{j} \| w_j \|^p \right)^{\frac{1}{p}}$
      where $p$ is the order of the induced norm

      :param order: the order of the induced norm.
      :type order: int


   .. py:method:: many_body_order(self)

      Compute the many-body order of a SymbolicOperator.

      The many-body order of a SymbolicOperator is the maximum length of
      a term with nonzero coefficient.

      :returns: int


   .. py:method:: accumulate(cls, operators, start=None)
      :classmethod:

      Sums over SymbolicOperators.


   .. py:method:: get_operators(self)

      Gets a list of operators with a single term.

      :returns: A generator of the operators in self.
      :rtype: operators([self.__class__])


   .. py:method:: get_operator_groups(self, num_groups)

      Gets a list of operators with a few terms.
      :param num_groups: How many operators to get in the end.
      :type num_groups: int

      :returns:

                A list of operators summing up to
                    self.
      :rtype: operators([self.__class__])



