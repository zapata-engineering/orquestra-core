:py:mod:`orquestra.quantum.openfermion.testing.performance_benchmarks`
======================================================================

.. py:module:: orquestra.quantum.openfermion.testing.performance_benchmarks

.. autoapi-nested-parse::

   This file contains tests of code performance to reveal bottlenecks.



Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   orquestra.quantum.openfermion.testing.performance_benchmarks.benchmark_molecular_operator_jordan_wigner
   orquestra.quantum.openfermion.testing.performance_benchmarks.benchmark_fermion_math_and_normal_order
   orquestra.quantum.openfermion.testing.performance_benchmarks.benchmark_jordan_wigner_sparse
   orquestra.quantum.openfermion.testing.performance_benchmarks.benchmark_linear_qubit_operator
   orquestra.quantum.openfermion.testing.performance_benchmarks.benchmark_commutator_diagonal_coulomb_operators_2D_spinless_jellium
   orquestra.quantum.openfermion.testing.performance_benchmarks.run_molecular_operator_jordan_wigner
   orquestra.quantum.openfermion.testing.performance_benchmarks.run_fermion_math_and_normal_order
   orquestra.quantum.openfermion.testing.performance_benchmarks.run_jordan_wigner_sparse
   orquestra.quantum.openfermion.testing.performance_benchmarks.run_linear_qubit_operator
   orquestra.quantum.openfermion.testing.performance_benchmarks.run_diagonal_commutator



.. py:function:: benchmark_molecular_operator_jordan_wigner(n_qubits)

   Test speed with which molecular operators transform to qubit operators.

   :param n_qubits: The size of the molecular operator instance. Ideally, we
                    would be able to transform to a qubit operator for 50 qubit
                    instances in less than a minute. We are way too slow right now.

   :returns: The number of seconds required to make the conversion.
   :rtype: runtime


.. py:function:: benchmark_fermion_math_and_normal_order(n_qubits, term_length, power)

   Benchmark both arithmetic operators and normal ordering on fermions.

   The idea is we generate two random FermionTerms, A and B, each acting
   on n_qubits with term_length operators. We then compute
   (A + B) ** power. This is costly that is the first benchmark. The second
   benchmark is in normal ordering whatever comes out.

   :param n_qubits: The number of qubits on which these terms act.
   :param term_length: The number of operators in each term.
   :param power: Int, the exponent to which to raise sum of the two terms.

   :returns: The time it takes to perform (A + B) ** power
             runtime_normal_order: The time it takes to perform
                 FermionOperator.normal_order()
   :rtype: runtime_math


.. py:function:: benchmark_jordan_wigner_sparse(n_qubits)

   Benchmark the speed at which a FermionOperator is mapped to a matrix.

   :param n_qubits: The number of qubits in the example.

   :returns: The time in seconds that the benchmark took.
   :rtype: runtime


.. py:function:: benchmark_linear_qubit_operator(n_qubits, n_terms, processes=None)

   Test speed with getting a linear operator from a Qubit Operator.

   :param n_qubits: The number of qubits, implying the dimension of the operator
                    is 2 ** n_qubits.
   :param n_terms: The number of terms in a qubit operator.
   :param processes: The number of processors to use.

   :returns: The time it takes to get the linear operator.
             runtime_matvec: The time it takes to perform matrix multiplication.
   :rtype: runtime_operator


.. py:function:: benchmark_commutator_diagonal_coulomb_operators_2D_spinless_jellium(side_length)

   Test speed of computing commutators using specialized functions.

   :param side_length: The side length of the 2D jellium grid. There are
                       side_length ** 2 qubits, and O(side_length ** 4) terms in the
                       Hamiltonian.

   :returns:

             The time it takes to compute a commutator, after
                 partitioning the terms and normal ordering, using the regular
                 commutator function.
             runtime_diagonal_commutator: The time it takes to compute the same
                 commutator using methods restricted to diagonal Coulomb operators.
   :rtype: runtime_commutator


.. py:function:: run_molecular_operator_jordan_wigner(n_qubits=18)

   Run InteractionOperator.jordan_wigner_transform() benchmark.


.. py:function:: run_fermion_math_and_normal_order(n_qubits=20, term_length=10, power=15)

   Run benchmark on FermionOperator math and normal-ordering.


.. py:function:: run_jordan_wigner_sparse(n_qubits=10)

   Run FermionOperator.jordan_wigner_sparse() benchmark.


.. py:function:: run_linear_qubit_operator(n_qubits=16, n_terms=10, processes=10)

   Run linear_qubit_operator benchmark.


.. py:function:: run_diagonal_commutator(side_length=4)

   Run commutator_diagonal_coulomb_operators benchmark.


