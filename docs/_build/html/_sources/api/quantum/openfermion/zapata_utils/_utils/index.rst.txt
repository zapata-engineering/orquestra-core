:orphan:

:py:mod:`quantum.openfermion.zapata_utils._utils`
=================================================

.. py:module:: quantum.openfermion.zapata_utils._utils


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   quantum.openfermion.zapata_utils._utils.get_qubitop_from_matrix
   quantum.openfermion.zapata_utils._utils.get_qubitop_from_coeffs_and_labels
   quantum.openfermion.zapata_utils._utils.generate_random_qubitop
   quantum.openfermion.zapata_utils._utils.evaluate_qubit_operator
   quantum.openfermion.zapata_utils._utils.evaluate_qubit_operator_list
   quantum.openfermion.zapata_utils._utils.reverse_qubit_order
   quantum.openfermion.zapata_utils._utils.get_expectation_value
   quantum.openfermion.zapata_utils._utils.change_operator_type
   quantum.openfermion.zapata_utils._utils.get_fermion_number_operator
   quantum.openfermion.zapata_utils._utils.get_diagonal_component
   quantum.openfermion.zapata_utils._utils.get_polynomial_tensor
   quantum.openfermion.zapata_utils._utils.create_circuits_from_qubit_operator
   quantum.openfermion.zapata_utils._utils.get_ground_state_rdm_from_qubit_op
   quantum.openfermion.zapata_utils._utils.remove_inactive_orbitals
   quantum.openfermion.zapata_utils._utils.hf_rdm



.. py:function:: get_qubitop_from_matrix(operator: List[List]) -> orquestra.quantum.openfermion.QubitOperator

   Expands a 2^n by 2^n matrix into n-qubit Pauli basis. The runtime of
   this function is O(2^2n).

   :param operator: a list of lists (rows) representing a 2^n by 2^n
                    matrix.

   :returns: A QubitOperator instance corresponding to the expansion of
             the input operator as a sum of Pauli strings:

             O = 2^-n \sum_P tr(O*P) P


.. py:function:: get_qubitop_from_coeffs_and_labels(coeffs: List[float], labels: List[List[int]]) -> orquestra.quantum.openfermion.QubitOperator

   Generates a QubitOperator based on a coefficient vector and
   a label matrix.

   :param coeffs: a list of floats representing the coefficients
                  for the terms in the Hamiltonian
   :param labels: a list of lists (a matrix) where each list
                  is a vector of integers representing the Pauli
                  string. See pauliutil.py for details.

   .. rubric:: Example

   The Hamiltonian H = 0.1 X1 X2 - 0.4 Y1 Y2 Z3 Z4 can be
   initiated by calling

   H = QubitOperator([0.1, -0.4],  # coefficients
       [[1 1 0 0],  # label matrix
       [2 2 3 3]])


.. py:function:: generate_random_qubitop(nqubits: int, nterms: int, nlocality: int, max_coeff: float, fixed_coeff: bool = False) -> orquestra.quantum.openfermion.QubitOperator

   Generates a Hamiltonian with term coefficients uniformly distributed
   in [-max_coeff, max_coeff].

   :param nqubits - number of qubits:
   :param nterms    - number of terms in the Hamiltonian:
   :param nlocality - locality of the Hamiltonian:
   :param max_coeff - bound for generating the term coefficients:
   :param fixed_coeff: max_coeff as coefficient.
   :type fixed_coeff: bool

   :returns: A QubitOperator with the appropriate coefficient vector
             and label matrix.


.. py:function:: evaluate_qubit_operator(qubit_operator: orquestra.quantum.openfermion.QubitOperator, expectation_values: orquestra.quantum.measurements.ExpectationValues) -> orquestra.quantum.utils.ValueEstimate

   Evaluate the expectation value of a qubit operator using expectation values for
   the terms.

   :param qubit_operator: the operator
   :param expectation_values: the expectation values

   :returns: stores the value of the expectation and its precision
   :rtype: value_estimate


.. py:function:: evaluate_qubit_operator_list(qubit_operator_list: List[orquestra.quantum.openfermion.QubitOperator], expectation_values: orquestra.quantum.measurements.ExpectationValues) -> orquestra.quantum.utils.ValueEstimate

   Evaluate the expectation value of a qubit operator list using expectation values
   for the terms. The expectation values should be in the order given by the qubit
   operator list, and the value returned is the sum of all terms in the qubit operator
   list.

   :param qubit_operator_list: the operator list
   :param expectation_values: the expectation values

   :returns: stores the value of the expectation and its precision
   :rtype: value_estimate


.. py:function:: reverse_qubit_order(qubit_operator: orquestra.quantum.openfermion.QubitOperator, n_qubits: Optional[int] = None)

   Reverse the order of qubit indices in a qubit operator.

   :param qubit_operator: the operator
   :type qubit_operator: openfermion.QubitOperator
   :param n_qubits: total number of qubits. Needs to be provided when
                    the size of the system of interest is greater than the size of qubit
                    operator (optional)
   :type n_qubits: int

   :returns: reversed_op (openfermion.ops.QubitOperator)


.. py:function:: get_expectation_value(qubit_op: orquestra.quantum.openfermion.QubitOperator, wavefunction: orquestra.quantum.wavefunction.Wavefunction, reverse_operator: bool = False) -> complex

   Get the expectation value of a qubit operator with respect to a wavefunction.
   :param qubit_op: the operator
   :param wavefunction: the wavefunction
   :param reverse_operator: whether to reverse order of qubit operator
                            before computing expectation value. This should be True if the convention
                            of the basis states used for the wavefunction is the opposite of the one in
                            the qubit operator. This is the case when the wavefunction uses
                            Rigetti convention (https://arxiv.org/abs/1711.02086) of ordering qubits.

   :returns: the expectation value


.. py:function:: change_operator_type(operator, operatorType)

   Take an operator and attempt to cast it to an operator of a different type

   :param operator: The operator
   :param operatorType: The type of the operator that the original operator is
                        cast to

   :returns: An operator with type operatorType


.. py:function:: get_fermion_number_operator(n_qubits, n_particles=None)

   Return a FermionOperator representing the number operator for n qubits.
   If `n_particles` is specified, it can be used for creating constraint on the number
   of particles.

   :param n_qubits: number of qubits in the system
   :type n_qubits: int
   :param n_particles: number of particles in the system.
                       If specified, it is subtracted from the number
                       operator such as expectation value is zero.
   :type n_particles: int

   :returns: the number operator
   :rtype: (openfermion.ops.FermionOperator)


.. py:function:: get_diagonal_component(operator)


.. py:function:: get_polynomial_tensor(fermion_operator, n_qubits=None)

   Convert a fermionic operator to a Polynomial Tensor.

   :param fermion_operator: The operator.
   :type fermion_operator: openferion.ops.FermionOperator
   :param n_qubits: The number of qubits to be included in the
                    PolynomialTensor. Must be at least equal to the number of qubits
                    that are acted on by fermion_operator. If None, then the number of
                    qubits is inferred from fermion_operator.
   :type n_qubits: int

   :returns:

             The tensor representation of the
                 operator.
   :rtype: openfermion.ops.PolynomialTensor


.. py:function:: create_circuits_from_qubit_operator(qubit_operator: orquestra.quantum.openfermion.QubitOperator) -> List[orquestra.quantum.circuits.Circuit]

   Creates a list of circuit objects from the Pauli terms of a QubitOperator
   :param qubit_operator: operator for which the Pauli terms are converted into circuits

   :returns: a list of Pauli string gate circuits
   :rtype: circuit_set


.. py:function:: get_ground_state_rdm_from_qubit_op(qubit_operator: orquestra.quantum.openfermion.QubitOperator, n_particles: int) -> orquestra.quantum.openfermion.InteractionRDM

   Diagonalize operator and compute the ground state 1- and 2-RDM

   :param qubit_operator: The openfermion operator to diagonalize
   :param n_particles: number of particles in the target ground state

   :returns: interaction RDM of the ground state with the particle number n_particles
   :rtype: rdm


.. py:function:: remove_inactive_orbitals(interaction_op: orquestra.quantum.openfermion.InteractionOperator, n_active: int = None, n_core: int = 0) -> orquestra.quantum.openfermion.InteractionOperator

   Remove orbitals not in the active space from an interaction operator.

   :param interaction_op: the operator, assumed to be ordered with alternating spin-up and
                          spin-down spin orbitals.
   :param n_active: the number of active molecular orbitals. If None, include all orbitals
                    beyond n_core. Note that the number of active spin orbitals will be twice
                    the number of active molecular orbitals.
   :param n_core: the number of core molecular orbitals to be frozen.

   :returns:

             The interaction operator with inactive orbitals removed, and the Hartree-Fock
                 energy of the core orbitals added to the constant.


.. py:function:: hf_rdm(n_alpha: int, n_beta: int, n_orbitals: int) -> orquestra.quantum.openfermion.InteractionRDM

   Construct the RDM corresponding to a Hartree-Fock state.

   :param n_alpha: number of spin-up electrons
   :type n_alpha: int
   :param n_beta: number of spin-down electrons
   :type n_beta: int
   :param n_orbitals: number of spatial orbitals (not spin orbitals)
   :type n_orbitals: int

   :returns: the reduced density matrix
   :rtype: openfermion.ops.InteractionRDM


